<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="generator" content="Hugo 0.79.1" />
	
	<title>Posts - by mikel evins</title>

	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
	<link href="http://mikelevins.github.io//css/bootstrap.min.css" rel="stylesheet">
	<link href="http://mikelevins.github.io//css/strange-case.css" rel="stylesheet">
	

	
	
	<!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

	
	<link href="http://mikelevins.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="engine of joy" />
</head>
<body class="scheme-joy">

	<div class="container-fluid">
		<div class="row">
			<div class="col-sm-4 col-md-3 col-lg-3 sidebar">

			
	<div class="sidebar-content">

		<a href="http://mikelevins.github.io/"><h1>engine of joy</h1></a>
		<p>by mikel evins</p>

		

		<ul class="sidebar-menus">
			
		</ul>

		<div class="sidebar-recent hidden-xs">
			<p>Recent Posts:</p>
			<ul>
				
				<li><a href="http://mikelevins.github.io/">engine of joy</a></li>
				
				<li><a href="http://mikelevins.github.io/posts/2020-12-18-repl-driven/">On repl-driven programming</a></li>
				
				<li><a href="http://mikelevins.github.io/posts/">Posts</a></li>
				
				<li><a href="http://mikelevins.github.io/tags/programming/">programming</a></li>
				
				<li><a href="http://mikelevins.github.io/tags/">Tags</a></li>
				
			</ul>
		</div>

		

		<p class="copyright">&copy; 2021. All rights reserved. </p>
		<p class="attr">Powered by <a href="http://gohugo.io">Hugo</a> &amp; <a href="https://github.com/ExchangeRate-API/strange-case">Strange Case</a> (inspired by <a href="https://github.com/poole/hyde">Hyde</a>).</p>

	</div>


			</div>
			<div class="col-sm-7 col-sm-offset-4 col-md-6 col-md-offset-3 col-lg-5 col-lg-offset-3 content">

				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2015-11-28-captain-rayleigh/">Captain Rayleigh</a></h1>
						<span>Nov 28, 2015</span>
					</div>

					<p>Esgar Rayleigh is <em>Kestrel&rsquo;s</em> captain. You know this has to be a formal portrait because you don&rsquo;t see a cup of coffee in his hand.</p>
<p><img src="http://i.imgur.com/DweeiMT.png" alt="Imgur"></p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2015-11-28-chief-engineer-burrell/">Chief Engineer Burrell</a></h1>
						<span>Nov 28, 2015</span>
					</div>

					<p>This is Evelyn Burrell, the chief engineer aboard <em>Kestrel</em>:</p>
<p><img src="http://i.imgur.com/1h8I88V.png" alt="A portrait of Evelyn Burrell" title="Evelyn Burrell"></p>
<p>I always do a lot of sketching and cartooning when I&rsquo;m working. I
don&rsquo;t always share the drawings, but I don&rsquo;t see why I shouldn&rsquo;t.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2010-01-23-general-public-busybody-theory/">General public busybody theory</a></h1>
						<span>Jan 23, 2010</span>
					</div>

					<p>I was idly thinking about the
<a href="http://en.wikipedia.org/wiki/Penny_Arcade_(webcomic)#John_Gabriel.27s_.22Greater_Internet_Fuckwad_Theory.22">GIFT</a>,
which comes up often for me because I not only surf the net, I also
play networked games, where the theory plays out so often and so
emphatically. I was also thinking about the things that people think
are weird and foolish in other people, because I happen to be
traveling this week, and those things vary somewhat from one place to
another.</p>
<p>It occurred to me when I thought about those things at the same time
that they suggest a reason for the generally widespread hatred of gay
people.</p>
<p>Personally, I&rsquo;m male and, sexually speaking, I like women. But I don&rsquo;t
particularly care whether another person prefers men or women or both,
or neither, regardless of their gender. It&rsquo;s a little hard for me to
see why anyone would care about such a thing, much less why they would
hold demonstrations or pass laws about it. It doesn&rsquo;t seem to me to be
a lot different from passing laws about what flavors of ice cream
you&rsquo;re allowed to like.</p>
<p>But when I was thinking about things today, a couple of things
occurred to me. First, I&rsquo;ve observed that there is a tendency sort of
similar to the
<a href="http://en.wikipedia.org/wiki/Penny_Arcade_(webcomic)#John_Gabriel.27s_.22Greater_Internet_Fuckwad_Theory.22">GIFT</a>,
which I might call the &ldquo;general public busybody theory&rdquo;, which is
that, first of all, a large fraction of people are inclined to be
busybodies, and the inclination increases as it gets easier and more
anonymous. In other words, the cheaper and easier it is to say that
somebody ought to do something, and the less well you know them, the
more likely you are to tell them what to do.</p>
<p>In general, I mean. Not everyone seems to have this impulse to boss
people around, but it does seem to be very common, and it seems like a
majority of people have it to some degree, some more than others.</p>
<p>The second piece of the puzzle is that if you have a sexual
preference&ndash;any sexual preference&ndash;then it&rsquo;s pretty likely to gross
another person out if he or she doesn&rsquo;t share it. I imagine that&rsquo;s one
reason that talking about sex is sort of impolite. That&rsquo;s a tacit
acknowledgement that people like different things, and what is
appealing to one person is upsetting to another.</p>
<p>This is not too surprising, really. If you&rsquo;re dispassionate about it,
all sex is at least a little bit gross and ridiculous. Being aroused,
of course, tends to obliterate any sense of embarrassment or distaste,
so we never get much chance to notice that the things we like are
weird or icky. But if you could somehow switch off all arousal, then I
think most people would notice that their own sexual tastes involve
things that are a little bit messy and undignified. It&rsquo;s pretty much
just the nature of mammalian reproduction to be that way.</p>
<p>But of course, people can&rsquo;t just turn off their sexual feelings, and
they&rsquo;re strong feelings. Accidentally discovering that someone is
turned on by something you are not can be very awkward. There&rsquo;s a sort
of &ldquo;EEEEEEWWWWW!!!&rdquo; moment that some folks in kinky-sex communities
call being &ldquo;squicked&rdquo;. You are &ldquo;squicked&rdquo; when you are repelled by
something that sexually appeals to someone else. The kinky-sex folks
run into it kind of a lot, of course, and talk about it and joke about
it, and have sort of social conventions for taking the sting out of
it, so it doesn&rsquo;t interfere with their hobbies or friendships. Folks
less communicative about their sexual preferences don&rsquo;t really have
those conventions, because they don&rsquo;t really have the need or occasion
to develop them, so their only experience of being &ldquo;squicked&rdquo; is
generally the thing itself&ndash;the experience of stumbling upon someone
with a sexual appetite that makes them go &ldquo;EEEEEEWWWWW!!!&rdquo;</p>
<p>Well, nobody likes that, of course. If a person has little experience
of such encounters, or of talking about the subject, awkwardness may
well ensue.</p>
<p>When you combine that with the general public busybody theory, you
have a situation that seems like it&rsquo;s almost tailor-made for creating
prejudice against gay people (or against anyone with any sort of
tastes or proclivities that are in the minority). An average
heterosexual person (who is fairly likely to be a busybody, because
any random person is fairly likely to be a busybody) encounters a
random gay couple holding hands or otherwise acting like they care for
one another. This suggests the thought that this couple might be
sexually involved. That creates the opportunity to imagine a sexual
situation that makes our random busybody go &ldquo;EEEEEEWWWWW!!!&rdquo;, which,
by the general public busybody theory, immediately creates a desire to
insist that they shouldn&rsquo;t be allowed to do that.</p>
<p>Once I think of it that way, the prejudice, demonstrations, and
legislation seem almost inevitable.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-10-23-a-peek-at-categories/">A peek at Categories</a></h1>
						<span>Oct 23, 2009</span>
					</div>

					<p>I&rsquo;ve begun preparations to package Categories for release. The first
thing I&rsquo;m doing is going over the surface syntax. In previous
iterations I&rsquo;ve built Categories from the bottom up, which confirmed
that the concepts and mechanisms worked, but left a few warts in the
surface syntax. This time, I figured I&rsquo;d start at the surface syntax
and work the other way, in hopes that the result will be more
congenial.</p>
<p>This rather long post describes the current state of the Categories
surface syntax. Those who are interested in such things are invited to
tell me what&rsquo;s wrong with it.</p>
<p>Categories has three logical parts: datatypes (representation),
functions (behavior), and domains (taxonomy). Following Larry Tesler&rsquo;s
maxim that &lsquo;simple things should be simple; complex things should be
possible,&rsquo; I&rsquo;ll start by describing just the simplest and most common
use-cases, and then make another pass through all three parts of the
system to add in the more complicated options.</p>
<h2 id="datatypes">Datatypes</h2>
<p>Representation is the province of Datatypes. Types are first-class
objects in Categories. They can be created by evaluating expressions,
passed to and returned from functions, and bound to variables.</p>
<p>Categories defines a set of primitive type objects that represent
built-in types of the underlying platform. For example, the Scheme
version defines primitive types like <code>&lt;pair&gt;</code> and <code>&lt;symbol&gt;</code>, and it
arranges for its reflective operations to return appropriate
values. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">? (<span style="color:#a6e22e">type</span> <span style="color:#e6db74">&#39;foo</span>)

&lt;symbol&gt;

? (<span style="color:#a6e22e">type?</span> <span style="color:#e6db74">&#39;foo</span> &lt;symbol&gt;)

<span style="color:#66d9ef">#t</span>
</code></pre></div><h2 id="type-synonyms">Type synonyms</h2>
<p>The simplest possible way to define a type is to say that it&rsquo;s the
same as some existing type. Of course, even simpler than that is to
just go ahead and use the existing type. But sometimes you want a
different name for the type, to better communicate its intended
use. Sometimes you want to use an existing type for now, but may want
to represent the data differently in the future. To make these uses
easier, Categories provides type synonyms:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;name&gt; 
  (<span style="color:#a6e22e">type-synonym</span> &lt;string&gt;))
</code></pre></div><p>By defining <code>&lt;name&gt;</code> as a synonym for <code>&lt;string&gt;</code> you can use <code>&lt;string&gt;</code>
objects to represent names, while calling them <code>&lt;name&gt;</code>s in your code to
clearly communicate their purpose. Later, if you find that you need to
represent names in some other way&ndash;say as some structured object that
takes into account various different kinds of names that people
use&ndash;you can replace the definition of <code>&lt;name&gt;</code>. You&rsquo;ll then have to
change the implementations of functions that operate on <code>&lt;name&gt;</code>s, of
course, but if you structure your APIs appropriately, that&rsquo;s all
you&rsquo;ll have to change.</p>
<h3 id="structures">Structures</h3>
<p>More commonly, we want to create structured types by grouping several
simpler types into named fields. In Categories, that kind of type is
called a structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;cartesian-point&gt; 
  (<span style="color:#a6e22e">structure</span> () x y))
</code></pre></div><p>Like other types, structures are first class objects. The above code
binds a new structure to the variable <code>&lt;cartesian-point&gt;</code>. The new
structure has two keys: x and y. Instances of <code>&lt;cartesian-point&gt;</code> will
contain two values, one stored on the key x, and the other stored on
the key y.</p>
<p>You can create an instance of a structure by applying the function
make to it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt;)
</code></pre></div><p>You can get the value associated with a key by applying the function
get-key:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">? (<span style="color:#a6e22e">get-key</span> (<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt;) <span style="color:#e6db74">&#39;x</span>)

Error: Unbound key x 
</code></pre></div><p>Unfortunately, we didn&rsquo;t specify any value for x when we created the
instance. You can do that by passing in an initializer for the key:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">? (<span style="color:#a6e22e">get-key</span> (<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt; x: <span style="color:#ae81ff">101</span>) <span style="color:#e6db74">&#39;x</span>) 

<span style="color:#ae81ff">101</span> 
</code></pre></div><p>You can also specify a default value for a key in the definition of
the type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;cartesian-point&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    (<span style="color:#a6e22e">x</span> default: <span style="color:#ae81ff">7</span>)
    y))

? (<span style="color:#a6e22e">get-key</span> (<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt;) <span style="color:#e6db74">&#39;x</span>) 
  
<span style="color:#ae81ff">7</span> 
</code></pre></div><p>Before I go any farther, I had better explain why there&rsquo;s an empty
list after the symbol &lsquo;structure&rsquo; in:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;cartesian-point&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    x
    y)) 
</code></pre></div><p>When you create a new structure, you can specify zero or more existing
structures to include in its definition. So if I wanted to define a
new type of 3D point that is just like a cartesian point, but with an
extra coordinate, I could define it like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;3d-point&gt; 
  (<span style="color:#a6e22e">structure</span> (<span style="color:#a6e22e">&lt;cartesian-point&gt;</span>) 
   z)) 
</code></pre></div><p>&lsquo;Okay,&rsquo; you&rsquo;re thinking, &lsquo;that&rsquo;s nothing new. The new type inherits
from the old one.&rsquo; Not so fast: there&rsquo;s no such thing as inheritance
in types. Including a type just means you don&rsquo;t have to retype all its
field definitions when you want to reuse them. Categories does support
inheritance, but that belongs to domains, not to datatypes. Remember:
datatypes are representation. Inheritance belongs to taxonomy, and
that&rsquo;s the province of domains, not of datatypes.</p>
<h3 id="structure-amenities">Structure amenities</h3>
<p>The structure constructor provides a few more conveniences. You can
say that you want Categories to automatically construct getter
functions for the new type&rsquo;s keys:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;cartesian-point&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    (<span style="color:#a6e22e">x</span> get: get-x) 
    (<span style="color:#a6e22e">y</span> get: get-y))) 
</code></pre></div><p>Now you can fetch the x value from a cartesian point like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">? (<span style="color:#a6e22e">get-x</span> (<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt; x: <span style="color:#ae81ff">101</span>))

<span style="color:#ae81ff">101</span> 
</code></pre></div><p>If you leave off the get: argument for a key, then you have to use
get-key and the key&rsquo;s name to fetch the value.</p>
<p>You can also specify a setter:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;cartesian-point&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    (<span style="color:#a6e22e">x</span> get: get-x set: set-x!)  
    (<span style="color:#a6e22e">y</span> get: get-y set: set-y!)))  
</code></pre></div><p>Categories then constructs a function for setting the value associated
with the key:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">? (<span style="color:#66d9ef">define </span>p (<span style="color:#a6e22e">make</span> &lt;cartesian-point&gt; x: <span style="color:#ae81ff">101</span>))

<span style="color:#f92672">#</span>&lt;&lt;cartesian-point&gt; x: <span style="color:#ae81ff">101</span> y: <span style="color:#f92672">#</span>&lt;unbound&gt;&gt;

? (<span style="color:#a6e22e">get-x</span> p) 

<span style="color:#ae81ff">101</span>

? (<span style="color:#a6e22e">set-x!</span> p <span style="color:#ae81ff">1001</span>) 

? (<span style="color:#a6e22e">get-x</span> p) 

<span style="color:#ae81ff">1001</span> 
</code></pre></div><p>If you omit the set: argument then Categories makes the key
read-only. Categories is generally biased in favor of immutable data.</p>
<h3 id="functions">Functions</h3>
<p>Now that we know how to define datatypes, what do we do with them? We
apply <strong>functions</strong> to them.</p>
<p>Functions are objects that can be applied to zero or more parameters
and return zero or more results. Functions as defined in Categories
are polymoprphic. In other words, the same function can have several
different definitions. The one that applies to a particular set of
inputs depends on the inputs.</p>
<p>This practice of making the particular implementation of a function
depend on its inputs is called <strong>polymorphism</strong>, and is one of the
foundations of object-oriented programming. Choosing a specific
implementation to run is called <strong>dispatching</strong>. Categories provides
polymorphic functions with programmable dispatching.</p>
<p>We&rsquo;ll look at how you can create your own dispatching schemes
below. First, though, let&rsquo;s look at what it&rsquo;s like to define and use
functions in the simplest way.</p>
<h3 id="the-default-domain">The Default domain</h3>
<p>The simplest way to define and use functions in Categories is with the
<strong>default domain</strong>. Categories assumes you are using the default
domain unless you tell it otherwise. The features of the default
domain generally resemble those of CLOS.</p>
<p>Like types, functions are first-class objects. You can create one and
bind it to a variable, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>serialize 
  (<span style="color:#a6e22e">function</span> ((<span style="color:#a6e22e">s</span> &lt;store&gt;))
    (vector <span style="color:#e6db74">&#39;store</span> 
            (<span style="color:#a6e22e">version</span> s) 
            (map serialize (<span style="color:#a6e22e">columns</span> s)) 
            (<span style="color:#a6e22e">column-order</span> s) 
            (<span style="color:#a6e22e">sort-column</span> s) 
            (<span style="color:#a6e22e">sort-reversed?</span> s) 
            (map serialize (<span style="color:#a6e22e">rows</span> s)) 
            (<span style="color:#a6e22e">notes</span> s)))) 
</code></pre></div><p>The function object that is bound to the variable named &lsquo;serialize&rsquo; is
created with a single implementation, corresponding to the type
<code>&lt;store&gt;</code>. If we want to add another implementation, we can use
add-method!:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">add-method!</span> serialize ((<span style="color:#a6e22e">d</span> &lt;document&gt;)) <span style="color:#f92672">...</span>)

</code></pre></div><p>Why do the parameter lists have double parentheses? Because each
parameter may be type-qualified:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">add-method!</span> serialize ((<span style="color:#a6e22e">d</span> &lt;document&gt;)(<span style="color:#a6e22e">outs</span> &lt;stream&gt;)) 
  <span style="color:#f92672">...</span>)  
</code></pre></div><p>You can define a method to execute when no match is found for the
inputs by omitting the type qualifiers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">add-method!</span> serialize (<span style="color:#a6e22e">something</span> somewhere) <span style="color:#f92672">...</span>)

</code></pre></div><p>It can be an inconvenience to keep track of where the definition of
the function first appears, and to make sure that all the add-method!
calls appear after it. If you instead use the define-function macro,
that bookkeeping is handled for you automatically:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> serialize ((<span style="color:#a6e22e">s</span> &lt;store&gt;)) <span style="color:#f92672">...</span>)

(<span style="color:#a6e22e">define-function</span> serialize ((<span style="color:#a6e22e">d</span> &lt;document&gt;)) <span style="color:#f92672">...</span>)
    
</code></pre></div><p>In that case, it doesn&rsquo;t matter which comes first.</p>
<h3 id="domains">Domains</h3>
<p>So how exactly does dispatching work in Categories? Well, that depends
on what domain you use. By default, you use the default domain. The
default domain, which is named -c3-, uses a dispatching algorithm very
similar to that of CLOS. It&rsquo;s not identical to CLOS; it uses a scheme
first described in</p>
<p><a href="http://192.220.96.201/dylan/linearization-oopsla96.html">http://192.220.96.201/dylan/linearization-oopsla96.html</a></p>
<p>That scheme, which is generally called &lsquo;C3,&rsquo; yields dispatching
behavior that is very similar to that of CLOS, but which in a few
complicated corner cases produces less surprising results. It&rsquo;s the
default in Categories because I like it, and because it has served the
general programming community well. It was designed for the Dylan
programming language, but has been adopted by implementors outside the
Dylan community, including the Python implementors and the designers
of the Class::C3 object system for Perl.</p>
<p>Although C3 is the default dispatching scheme, it&rsquo;s not the only
dispatching scheme supported by Categories.  Two other dispatching
schemes are provided with Categories, and by defining domains, you can
make your own.</p>
<p>Before we get to that, though, let&rsquo;s just look at how to use something
other than the default domain.</p>
<p>When you write:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> serialize ((<span style="color:#a6e22e">s</span> &lt;store&gt;)) <span style="color:#f92672">...</span>)  
</code></pre></div><p>that expression is really shorthand. It leaves out a reference to the
domain you&rsquo;re using. If we wrote it out in full, it would look like
this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> -c3- serialize ((<span style="color:#a6e22e">s</span> &lt;store&gt;)) <span style="color:#f92672">...</span>)  
</code></pre></div><p>You can see that here we&rsquo;ve said explicitly that we&rsquo;re defining a
function that operates in the -c3- domain. We could instead use one of
the other domains supplied with Categories, the Flat domain:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> -flat- serialize ((<span style="color:#a6e22e">s</span> &lt;store&gt;)) <span style="color:#f92672">...</span>)  
</code></pre></div><p>The difference between -c3- and -flat- is that -c3- defines supertype
relations among types, and -flat- doesn&rsquo;t. Suppose you make an
instance of <!-- raw HTML omitted --> and call serialize on it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>$r (<span style="color:#a6e22e">make</span> &lt;repository&gt;)) 

(<span style="color:#a6e22e">serialize</span> $r) 
</code></pre></div><p>What happens? That depends on whether serialize is defined on the -c3-
or on the -flat- domain. It&rsquo;s the domain that defines how dispatching
is done. If it&rsquo;s defined on -flat- then the answer is simple:
serialize finds no match for $r. Unless a default method is defined as
in the example above, an error is signaled.</p>
<p>The -c3- domain defines a more complicated&ndash;and more
familiar&ndash;dispatching scheme. It will try to match $r against
serialize methods that are defined on <code>&lt;repository&gt;</code>.  When it fails to
find one, it then tries to find serialize methods defined on
supertypes of <code>&lt;repository&gt;</code>.</p>
<p>Didn&rsquo;t I say above that datatypes don&rsquo;t define supertype or
inheritance relations? Yes, because <em>domains</em> do. The -c3- domain
defines supertype relations with multiple inheritance. It tries to
find an inherited method that matches, using the C3 algorithm to
determine which matching method is most specific. Once again, if no
such method is found then either the default method is called or, if
there is no default method, an error is signaled.</p>
<h3 id="more-options">More options</h3>
<p>That&rsquo;s a first pass across the simplest and most commonly-used
features of Categories. Let&rsquo;s go over the parts of the system one more
time, and look at a few more options that it provides.</p>
<h3 id="categories">Categories</h3>
<p>First of all, I left out an important group of types, because it&rsquo;s
hard to explain what they&rsquo;re for until you&rsquo;ve seen how Categories
works with domains. A constructor named &lsquo;category&rsquo; creates a kind of
type that is different from the others. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;vehicle&gt; (<span style="color:#a6e22e">category</span> &lt;car&gt; &lt;truck&gt;)) 
</code></pre></div><p>The expression above binds a new type to <code>&lt;vehicle&gt;</code>. The new type,
which is called a category, represents any of the types passed as
inputs to the &lsquo;category&rsquo; constructor. Once <code>&lt;vehicle&gt;</code> is defined, any
method matching <code>&lt;vehicle&gt;</code> will also apply to <code>&lt;car&gt;</code> or
<code>&lt;truck&gt;</code>. You can therefore define functions that accept <code>&lt;vehicle&gt;</code>
values, and those functions will work on <code>&lt;car&gt;</code> or <code>&lt;truck&gt;</code> values,
<em>even if the functions are defined on the flat domain</em>. In other
words, even without inheritance, it is possible to define functions
that operate the same way on a variety of different types.</p>
<h3 id="supertypes-and-subtypes">Supertypes and subtypes</h3>
<p>Okay, but suppose you actually want types that have supertypes and
subtypes? Well, then, you can use -c3-,or any domain that supports
supertype relations, and you can add your own types to it. For
example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">add-type!</span> -c3- &lt;truck&gt; 
  supertypes: (list &lt;transportation&gt; &lt;four-wheeled-objects&gt;)) 
</code></pre></div><p>&hellip;adds to -c3- a type named <code>&lt;truck&gt;</code>, with supertypes
<code>&lt;transportation&gt;</code> and <code>&lt;four-wheeled-objects&gt;</code>.</p>
<p>You can, of course, also add types to the -flat- domain:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">add-type!</span> -flat- &lt;truck&gt;) 
</code></pre></div><p>You can&rsquo;t specify any supertypes for it, though, because -flat-
doesn&rsquo;t support supertype relations. If you try to, then add-type!
will signal an error.</p>
<h3 id="name-collisions">Name collisions</h3>
<p>What happens if I define a type that includes two other types that
have different definitions for the same key?</p>
<p>For example, suppose I have these two definitions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;monument&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    (<span style="color:#a6e22e">age</span> type: &lt;historical-epoch&gt;))

(<span style="color:#66d9ef">define </span>&lt;property&gt; 
  (<span style="color:#a6e22e">structure</span> () 
    (<span style="color:#a6e22e">age</span> type: &lt;count-of-years&gt;)) 
</code></pre></div><p>Now suppose I want to define <code>&lt;historic-property&gt;</code> like
this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;historic-property&gt; 
  (<span style="color:#a6e22e">structure</span> (<span style="color:#a6e22e">&lt;monument&gt;</span> &lt;property&gt;) 
    (<span style="color:#a6e22e">square-footage</span> asking-price)) 
</code></pre></div><p>Well, I can&rsquo;t. The definition of age in <code>&lt;monument&gt;</code> conflicts with
the definition of age in <code>&lt;property&gt;</code>. What I can do, though, is
rename one or both of the included keys:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>&lt;historic-property&gt; 
  (<span style="color:#a6e22e">structure</span> ((<span style="color:#a6e22e">&lt;monument&gt;</span> (<span style="color:#a6e22e">age</span> as: period))
              (<span style="color:#a6e22e">&lt;property&gt;</span> (<span style="color:#a6e22e">age</span> as: how-old)))
    (<span style="color:#a6e22e">square-footage</span> asking-price))) 
</code></pre></div><h3 id="the-predicate-domain">The Predicate domain</h3>
<p>Besides the default C3 domain and the flat domain, Categories includes
a third domain that works very differently from either. The -pred-
domain matches input function arguments with a user-defined predicate
function. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> -pred- ((<span style="color:#a6e22e">x</span> y z) all-odd?)  <span style="color:#f92672">...</span>)

</code></pre></div><p>The example above shows a function that will match any three inputs,
as long as calling the function all-odd? on the sequence of three
inputs returns true. You can define functions that match on any
predicate you like. You just have to ensure that when the function
passes the inputs to your predicate, the predicate correctly returns
either true or false.</p>
<p>The -pred- domain also uses the C3 algorithm to support supertype
relations among predicates. Using the -pred- domain you can construct
whatever relations among predicate functions you like, and Categories
will dispatch appropriately. For example, you define all-integers? to
be a supertype of all-odd?, and then anything that matches all-odd?
will also match all-integers?.</p>
<p>I should probably mention here that -pred- may not be all that useful
to anyone. It exists mainly because I wanted to make sure that it was
workable to build a dispatching scheme in Categories that was quite a
bit different from the usual thing.</p>
<p>One mystery remains with the -pred- domain, though: the syntax for
defining a function is different from the syntax used with the -c3-
and -flat- domains. How does that work?</p>
<h3 id="defining-domains">Defining domains</h3>
<p>The unique define-function syntax of the -pred- domain is provided by
the domain itself. It turns out that the operators &lsquo;function&rsquo; and
define-function' don&rsquo;t define the syntax of parameter lists; the
domain does. The -c3- and -flat- domains both define a syntax that is
familiar to users of CLOS and similar object systems. You write
define-function forms like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> -c3- add ((<span style="color:#a6e22e">x</span> &lt;integer&gt;)(<span style="color:#a6e22e">y</span> &lt;integer&gt;)) <span style="color:#f92672">...</span>)  
</code></pre></div><p>The forms <code>(x &lt;integer&gt;)</code> and <code>(y &lt;integer&gt;)</code> mean that the formal
parameters x and y match inputs only if those inputs can be matched
with the <code>&lt;integer&gt;</code> type, according to the domain.</p>
<p>A domain like -pred- works quite differently, and requires a different
syntax for parameter lists. Instead of piecewise matching input values
against types, -pred- matches the parameter list as a whole against
predicates applied to it. That makes it possible to dispatch on
conditions that -c3- and -flat- can&rsquo;t check. For example, -pred- can
match a sequence of five integers that are monotonically increasing,
or a sequence of characters that forms a palindrome.</p>
<p>But if some domains require unique parameter-list syntax, that means
Categories must have a way to define that syntax; and it does.</p>
<p>When you define a domain, you are defining three things:</p>
<ol>
<li>
<p>a format for function parameter lists</p>
</li>
<li>
<p>a function that determines whether a particular method matches a
given sequence of input values</p>
</li>
<li>
<p>a function that can tell you which of two methods better matches a
given set of inputs</p>
</li>
</ol>
<p>Here&rsquo;s what a domain definition looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>-my-domain- 
  (<span style="color:#a6e22e">domain</span> catalog: some-catalog-data-structure 
          parser: (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">domain</span> formals) <span style="color:#f92672">...</span>)
          matcher: (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">domain</span> signature values) <span style="color:#f92672">...</span>)  
          comparator: (<span style="color:#66d9ef">lambda </span>(<span style="color:#a6e22e">domain</span> signature1 signature2 values) <span style="color:#f92672">...</span>)))  
</code></pre></div><p>Right away you&rsquo;ll notice that, although I said you have to define
three things, there are four inputs to the domain
constructor. Categories provides each domain with a data structure
called a <strong>catalog</strong>. The catalog can be anything you like. It can be
a false value, or an integer, or a table, or a more complex data
structure. It&rsquo;s up to you. Its purpose is to provide storage for any
auxiliary data that your domain might need to perform its tasks
correctly and efficiently. You can use it to store method caches, or
arrangements of supertypes designed to make lookup fast, or whatever
you wish. You can also ignore it completely, if you wish.</p>
<p>The other inputs to the domain constructor are essential, though. Each
of them is a function that defines one aspect of how the domain
works. Because your domain may have crucial data stored in its
catalog, all three of the functions accept the domain itself as the
first argument. Its up to you what you do with that argument; it&rsquo;s
available in case you need it.</p>
<p>Besides the domain parameter, the functions that define a domain deal
with three other items: formal parameters, method signatures, and
input values.</p>
<p>A formal parameter is an object that represents the formal arguments
in a function definition. Categories doesn&rsquo;t define the format of
argument lists; that&rsquo;s up to the domain. When it processes a function
definition, it extracts the formal parameter from the function or
define-function expression, and passes it to the domain&rsquo;s parser. The
parser must accept the formal parameter and return a method
signature. It&rsquo;s the parser that determines what the argument list of a
function definition looks like.</p>
<p>The parser doesn&rsquo;t have to be complicated. Consider a -c3- function
definition again:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#a6e22e">define-function</span> -c3- add ((<span style="color:#a6e22e">x</span> &lt;integer&gt;)(<span style="color:#a6e22e">y</span> &lt;integer&gt;)) <span style="color:#f92672">...</span>)  
</code></pre></div><p>All the parser needs to do is collect the type qualifiers from the
formal parameter list, which is <code>((x &lt;integer&gt;)(y &lt;integer&gt;))</code>, and
make a method signature that matches two inputs that are both of type
<code>&lt;integer&gt;</code>.</p>
<p>That brings us to method signatures, and to the matcher. Once again,
the method signature can be any data structure you like, as long as it
stores the information that the matcher needs. Categories passes to
the matcher a method signature and a collection of input values. The
matcher must return true if the signature matches the inputs, and
false otherwise. For -c3-, a method signature can simply be a sequence
of types. For example, the method signature for the add function
defined above is just <code>(&lt;integer&gt; &lt;integer&gt;)</code>. The -c3- domain will
say that any sequence of two values matches that signature, as long as
both are of type <code>&lt;integer&gt;</code>, or of some type that, according to -c3-,
is a subtype of <code>&lt;integer&gt;</code>.</p>
<p>What if more than one signature matches a set of inputs? How does the
domain know what to do?</p>
<p>That&rsquo;s what the comparator is for. After a function determines all the
signatures that match a set of inputs, it sorts them. The comparator
is the function it uses to determine their order. The comparator must
accept two signatures and a sequence of input values. If the first
signature is a better match than the second for the inputs, then the
comparator returns -1. If the second signature is a better match, it
returns 1. If neither is better, it returns 0. It&rsquo;s best to try to
arrange for the comparator not to return zero, if that makes sense for
the domain you&rsquo;re designing, because returning zero means you can&rsquo;t
tell which method to apply. Categories has to signal a dispatch error
when that happens.</p>
<h3 id="customizing-the-default-domain">Customizing the default domain</h3>
<p>It may happen that you want to make your own domain, but you don&rsquo;t
really want to totally rewrite how everything works. Maybe, for
example, you want to use something other than C3 to order methods, but
everything else about how Categories works suits you fine. In order to
make it easier to customize just the part you want to customize,
Categories provides functions that implement the behavior of the
default domain. You can make your own domains using them, and you can
replace just one of them, or two of them, or you can use all of the
standard functions, but change their inputs or outputs a little using
your own code.</p>
<p>As an example, you can make a domain that duplicates the behavior of
the default domain like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>-my-c3-domain- 
  (<span style="color:#a6e22e">domain</span> catalog: (<span style="color:#a6e22e">make-c3-catalog</span>)
          parser: (<span style="color:#a6e22e">c3-signature-parser</span>) 
          matcher: (<span style="color:#a6e22e">c3-signature-matcher</span>)
          comparator: (<span style="color:#a6e22e">c3-signature-comparator</span>))) 
</code></pre></div><h3 id="what-next">What next?</h3>
<p>All of the features described in this overview have been implemented,
but the working code doesn&rsquo;t provide this surface syntax. The syntax
of the working versions is not too different in most places, but it&rsquo;s
a little more complicated and not quite so tidy. I&rsquo;ll be fixing that
as part of getting the code ready for release.</p>
<p>The prototype I&rsquo;ve most recently been working on is implemented on top
of Gambit Scheme 4.5.2. I&rsquo;ve tried to avoid making it particularly
Gambit-specific, but the surface syntax I chose does use DSSSL
keywords, which not all Schemes support. In addition, some of the
syntax needs to be defined as macros. For reasons of convenience,
those will be defined using Gambit&rsquo;s define-macro form, rather than
something more portable. It may turn out that someone wants Categories
on some Scheme that lacks DSSSL keywords, or where a different means
of defining macros is needed. I&rsquo;ll cross that bridge when I come to
it.</p>
<p>I plan to port it back to Clojure, as well. The first few versions of
Categories were written in Clojure, but I wanted to move it elsewhere,
mainly to gain the perspective of looking at it as something
independent of a particular language, rather than as an extension
specifically to Clojure. I&rsquo;m planning a sizeable project in Clojure
shortly, though, and I know for sure that I&rsquo;ll want what Categories
offers me for it.</p>
<p>It may be that the design of Categories has serious flaws. If so, feel
free to enlighten me about them. If they can be repaired, I&rsquo;ll do my
best to fix them. If not, I&rsquo;ll have to look for alternatives. I could
always port <a href="http://github.com/adlai/sheeple">Sheeple</a> to Clojure, or
maybe implement <a href="http://users.rcn.com/david-moon/PLOT/">PLOT&rsquo;s</a> object
system.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-10-18-gambit-considered-helpful/">Gambit considered helpful</a></h1>
						<span>Oct 18, 2009</span>
					</div>

					<p>I&rsquo;ve just packed up Delectus(tm) 1.0 Alpha 2 and shipped it off to my
testers. Delectus is an application for keeping track of collections
of things. The inspiration for it was an ancient and hoary program my
mother used to keep track of her movies. She has around a thousand
movies, the majority of them still on videocassettes. Each cassette
has a catalog number on it, and she uses a database program to
associate those numbers with information like the title, star, genre,
and so forth, so that she can quickly find a particular movie in her
stacks of shelves. Recently the software, which is over twenty years
old, finally became obsolete. As we were looking for a replacement, I
decided I&rsquo;d just write one, and that became the genesis of Delectus.</p>
<p>The basic design of Delectus is very simple. A Delectus document
stores a list of rows and a list of columns. Each column has a text
label. Each row contains a list of text fields. The number of fields
is the same in every row, and it&rsquo;s also the same as the number of
columns. So you can create a document with the columns &ldquo;Title&rdquo;,
&ldquo;Genre&rdquo;, and &ldquo;Star&rdquo;, and every row will then have three fields. You
can make a new row and put the title of a movie into the &ldquo;Title&rdquo;
field, the star into the &ldquo;Star&rdquo; field, and the genre into the &ldquo;Genre&rdquo;
field.</p>
<p>Delectus doesn&rsquo;t decide for you how many columns to create or what the
names will be. Instead, a new Delectus document has no rows and no
columns. You can add new rows and new columns at any time, and you can
delete them at any time, too. This flexibility makes it easy to set up
your databases any way that is convenient for you. You can sort a
document&rsquo;s entries, forward or backward, by clicking the heading of a
column. If every entry in a column is a number, Delectus detects that
automatically, and sorts by number instead of lexicographically.</p>
<p>Delectus uses a trash can, like OS X&rsquo;s trash can. When you delete a
row or column, it&rsquo;s not really gone, but tossed into the trash. Click
a trash button, and Delectus shows the trash to you, integrated in the
document, but displayed in a different color, so you can easily tell
which items are deleted. Empty the trash, of course, and the deleted
items are gone forever.</p>
<p>Delectus is mainly written in Scheme. The Scheme compiler I&rsquo;m using is
Gambit-C. A few weeks ago, I wrote a post about the happy discovery
that Gambit-C made it easy to work with Mac OS X&rsquo;s Cocoa frameworks. I
said Gambit was a great platform for Cocoa development. That opinion
drew some fire, but I haven&rsquo;t changed it. To the contrary, I&rsquo;ve grown
happier with Gambit as I&rsquo;ve developed Delectus.</p>
<p>Some people grumbled that I&rsquo;m not allowed to call it a great platform
if I still have to deal with C code. Now, that&rsquo;s silly. You know, I
actually had a Lisp system once in which I never had to deal with C
code. It was called a Symbolics Lisp Machine, Every other Lisp I&rsquo;ve
used&ndash;and I&rsquo;ve used a lot of them in twenty one years of
programming&ndash;has had to deal with C in one way or another, at one time
or another. Heck, even when I was writing Lisp code for an operating
system written in Lisp (an unshipped version of Apple&rsquo;s Newton), we
had to deal with C code. If your eyes are damaged by the sight of
semicolons, a hard road awaits you. C code is in the underpinnings of
every system you are ever likely to use. At least Gambit makes it easy
to wrap our beloved parentheses around it, so that the hothouse
flowers in our midst are protected from the hot exhaust bits spewing
forth from the C code beneath our feet.</p>
<p>The other common complaint seems to be that I made a grammatical error
in using the adjective &ldquo;great&rdquo; to modify a set of development tools
that does not include an IDE. To paraphrase Yoda, &ldquo;IDEs not make one
great.&rdquo;  Sure, there have been great IDEs. Smalltalk-80 was a great
IDE. Xerox Interlisp was a great IDE. Most IDEs are not great. Most
IDEs are <em>going</em> to be great, someday. That is, they&rsquo;re going to be
great, right up to the point where the weight of the implementation
collapses the envelope of optimism providing their buoyancy, and they
crumple into a heap of random features, slowly and inexorably sinking
under their combined mass.</p>
<p>IDEs are large, complicated systems that require serious design and
engineering. They are major cost centers to anyone who is not in the
business of selling IDEs, and the market for them is small. It should
not be surprising that they&rsquo;re mostly not all that good.</p>
<p>What&rsquo;s more, the benefit of even a great IDE is, let&rsquo;s face it,
marginal, as long as the basic tools are comprehensive and good. So
yeah, I&rsquo;d like to have a great IDE. I&rsquo;m not holding my breath. Maybe
I&rsquo;ll like the Factor IDE. It looks pretty good. But I&rsquo;m working in
Scheme, right now.</p>
<p>So, yeah, folks who never want to see a line of C code, you&rsquo;re not
going to like the tools I&rsquo;m using. Ditto for anyone who must have his
projects managed by a digital valet in an impeccably-tailored suit of
color-coordinated windows. There&rsquo;s nothing for you guys to see here;
move along.</p>
<p>For me, though, Gambit has definitely been great. In the development
of Delectus, I&rsquo;ve ditched XCode (but not Interface Builder). In Alpha
2, 83% of the application code by linecount is Scheme code. The
remaining 17% is Objective-C. Basically, there&rsquo;s just enough
Objective-C to load the nibfiles that define the app&rsquo;s windows and
menus, and hook their event-handlers to the Scheme code that does all
the real work.</p>
<p>After some experimentation, I partitioned the application into the
following parts:</p>
<ol>
<li>
<p>The back-end: this is pure Scheme code that handles all the data
structures, as well as sorting, filtering, and updating. It also
handles serializing and deserializing data as CSV and a native
binary format, and writing to and reading from disk files.</p>
</li>
<li>
<p>The UI: this is Objective-C code that loads the nibfiles, sets up
calls into the back-end, responds to notifications that originate
in the back-end, and provides the minor customizations I needed
to make Apple&rsquo;s UI elements look just the way I wanted. This part
is less than 700 lines of code, total.</p>
</li>
<li>
<p>The bridge. This is a small amount of Scheme code, and an even
smaller amount of Objective-C code, in a couple of files. It
provides simple utilities like a means of converting Scheme
strings to NSString objects when the UI needs to fetch a string
from the back-end, without being prodigal about allocation of
strings. It provides a mechanism for notifying the Objective-C
code from Scheme code, so that the pure-Scheme back-end can post
error messages, update requests, and other notifications, without
any code that is actually aware that an Objective-C component
exists.</p>
</li>
</ol>
<p>The last point is maybe interesting. There is a very small amount of
mixed Scheme/C code that enables the Objective-C UI to interact
productively with the Scheme back-end. I could easily have put that
code into the main body of the back-end proper, and at first, that&rsquo;s
what I did. After all, there&rsquo;s only a little of it; what&rsquo;s the harm?</p>
<p>Before long though, I refactored the code to completely separate all
that code into a bridge layer. The reason, basically, is that I like
to have a fairly comprehensive set of unit tests around my major
application functionality. With such a set of tests in place, it&rsquo;s
very easy to detect when a change in the code makes an application
feature fail, and it&rsquo;s easy to find what broke it. By factoring all of
the mixed code out into its own small layer, I was able to make the
back-end pure Scheme code, with no reference anywhere to any foreign
functions. That means that I can load the entire back-end into an
interactive repl and exercise it. I can run all the unit tests at
once, or run particular ones interactively. If one breaks, I can use
the interactive debugger to crawl around inside the back-end&rsquo;s runtime
and figure out what&rsquo;s wrong.</p>
<p>Furthermore, by factoring things this way, I create a circumscribed
and coherent API for calling into the back-end and getting data from
it. That makes it very easy to hook up the Cocoa UI, simply by having
event-handlers call the appropriate API functions. UI calls into the
back-end are almost always one or two lines of code. That means that,
even when a bug is in the UI rather than the back-end, the way the app
is factored makes that easy to detect. And since there is so little
front-end code, it&rsquo;s easy to find and fix.</p>
<p>Obviously, you could structure any Cocoa app similarly, whether the
back-end is Scheme or C or ML or whatever. What makes Gambit great for
me, a Lisp hacker by preference, is that over eighty percent of the
code I work with is pure Scheme code that I can work with
interactively, in the way I prefer.</p>
<p>You could argue that Delectus is really a C program, on the grounds
that Gambit-C compiles Scheme to C, before subsequently compiling it
to native code. That suits me fine, as long as I can continue to write
my C code in Scheme.</p>
<p>I&rsquo;ll say it again: Gambit-C has been a great platform for developing a
Cocoa app. I&rsquo;ll enthusiastically use it again in the future to do the
same kind of work. I would recommend it to anyone who wants to use
Lisp to write a Cocoa app, provided that they&rsquo;re not allergic to C
code, and provided that they&rsquo;re okay with using compilers and editors
without an IDE to command the servants for them.</p>
<p>Delectus should be out soon. The gating factor right now is the
opinion of the testers. When they&rsquo;re happy with the feature set and
the stability of the product, I&rsquo;ll release it.</p>
<p>After the release of Delectus, I&rsquo;ll begin work on a web application
aimed at MMORPG players. Most likely, the server side of that
application will be written in Clojure.</p>
<p>A little while ago, I promised interested people that they would soon
be able to get their hands on my Categories object system. The object
system had to take a back seat to revenue-generating work, but when
Delectus is out, I&rsquo;ll be working on a release of Categories. I intend
to use it in my next product anyway, and so I may as well also package
it for release to the tiny community of people who are interested in
such things.</p>
<p>The current working prototype of Categories runs on Gambit, and it&rsquo;s
likely that&rsquo;s the version I&rsquo;ll clean up and release first. Then I&rsquo;ll
port it back to Clojure (which is where I developed the first versions
of it), and make that available as well. It may be a little while
before I do either; we must now wait on the verdict of my
testers. When they say Delectus is done, then I can move forward.</p>
<p>I have several other plans in the works, including the resurrection of
some old friends. After six years, I still occasionally get fan mail
about Alpaca, the text editor. Those few fans may be glad to know that
a new version of Alpaca is on the roadmap. Another old project that
I&rsquo;m still sometimes asked about is Bosco, a simple set of tools for
building a Cocoa application in Clozure Common Lisp. Well, Bosco was
absorbed into Clozure Common Lisp a couple of years ago, but there
stlll seems to be a place under the sun for a small package of files
that shows how to build a minimal Cocoa application with the smallest
possible amount of Lisp code. I have another project called Apis that
can serve that purpose, among others. Apis, and other things derived
from it, are also on the roadmap.</p>
<p>There are other things, but they&rsquo;re even further down the road. For
now, I&rsquo;m still squarely in the midst of Delectus, and loving
Gambit. Turns out it&rsquo;s still a great platform for developing Cocoa
apps.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-08-13-categories/">Categories</a></h1>
						<span>Aug 13, 2009</span>
					</div>

					<p>There are a few things I&rsquo;ve written that I see cited or quoted
repeatedly. The oldest is a quip about omnipotent beings that I wrote
eighteen years ago in a USENET discussion:</p>
<p>&ldquo;Perhaps this morning there were only three Euclidean solids, but god
changed its mind retroactively at lunchtime, remaking the whole
history of the universe.  That&rsquo;s the way it is with omnipotent
beings.&rdquo;</p>
<p>More recent is an explanation I once gave of the concept of &ldquo;natural
law&rdquo; in politics. There are a couple of basic theories of law; one of
them is called &ldquo;natural law&rdquo;. Because that phrase is also used to mean
&ldquo;law of nature&rdquo;, people sometimes confuse the two concepts, often, I
think, because they&rsquo;re not aware that the legal one exists, or are not
aware of what it is. This was my attempt to succinctly summarize it in
one discussion:</p>
<p>&ldquo;People will naturally and predictably find some methods for resolving
[&hellip;] conflicts more congenial than others. There are some classes of
conflict for which people will naturally and predictably find certain
kinds of resolutions more congenial than others. The procedures people
find more congenial will also produce the resolutions people find more
congenial. And the procedures and resolutions that people find more
congenial will tend to resemble each other across times and cultures.&rdquo;</p>
<p>Two others are more technical articles that I wrote early in the 1990s
about programming. They were published in a magazine aimed at Mac
developers, called Frameworks.</p>
<p>&ldquo;Objects Without Classes&rdquo; was republished by the ACM&rsquo;s Computer
magazine in Volume 27 , Issue 3 (March 1994) . It&rsquo;s a basic
description of prototype-based object systems, such as those found in
languages like Self and Javascript. Languages with prototype-based
object systems probably seemed novel to more people then than they do
now. Lots of people use Javascript now, but at that time you might
never have heard of prototype-based object systems unless you were at
Sun working on Self, or in the AI business, working with frame
languages, or at Apple working on Newton or SK8.</p>
<p>The topic of this post is the ideas presented in &ldquo;Protocols,&rdquo;
originally published in the March, 1994 issue of Frameworks, and
archived at
<a href="http://www.mactech.com/articles/frameworks/8_2/Protocol_Evins.html">http://www.mactech.com/articles/frameworks/8_2/Protocol_Evins.html</a>. It&rsquo;s
an article about how representation, behavior, and taxonomy are
distinct concepts that can be handled separately, despite the fact
that object-oriented languages tend to confuse them.</p>
<p>Those points need clarifying, I know.</p>
<p>By &ldquo;representation,&rdquo; I mean how we concretely lay out data. As an
example, you can represent an array as a contiguous sequence of memory
locations, or as a table of indexes paired with pointers, or as a tree
of cells in which bit patterns are mapped to subtrees, or, of course,
in many other ways. There are circumstances in which each of the
different approaches might be advantageous. These are different
<em>representations</em> of a common abstract concept that I have here called
an &ldquo;array&rdquo;.</p>
<p>By &ldquo;behavior,&rdquo; I mean the set of operations that is defined on any
given set of values. Taking the abovementioned abstract concept of an
&ldquo;array&rdquo; as an example, you can use any of the mentioned
representations to support a common behavior. You can
straightforwardly implement functions that fetch an element of an
array by index, that iterate over the members of an array, that write
a new value to the array at some specified index. The implementation
and performance details will differ, of course, because the
representation differs, but the behavior—that is, the API and what it
accomplishes—is the same.</p>
<p>By &ldquo;taxonomy,&rdquo; I mean the relationship between one defined set of
values and another. Types are categories of values. They are (possibly
unbounded) collections of data objects. Types naturally have subtypes;
a collection of values has a natural relation to a smaller collection
of some of the same values: the smaller set is a subtype of the larger
one. It&rsquo;s natural to think of obtaining the smaller set by starting
with the larger one and adding restrictions that filter out some
values. You can think of taxonomies of types, such as the class
hierarchies in languages like Smalltalk and Java, as sets of values
that begin with a very inclusive type, like Java&rsquo;s Object, and
develops more and more refined types by adding more and more exclusive
restrictions. Object is all the values (I know; it&rsquo;s not really all of
them.) Number excludes all those objects that aren&rsquo;t representations
of magnitudes. Integer excludes all that are not representations of
whole numbers. And so on.</p>
<p>These three concepts, representation, behavior, and taxonomy, are
quite distinct, but most object-oriented languages conflate at least
two of them. Some combine all three. Smalltalk classes, for example,
are representation, behavior, and taxonomy all rolled into one. The
representation is in the instance variables; the behavior is in the
methods; the taxonomy is in the subclass/superclass relations. THe
trouble with that approach is that when you ask for one of the three,
you get the other two whether you want them or not. For example, if
you create a new subclass, you inherit representation, behavior, and
taxonomy, even if all you wanted was behavior. If you create some
subclass because you want a certain taxonomic relation, you also get a
representation and a behavior that may or may not be what you need.</p>
<p>The claim of the &ldquo;Prototypes&rdquo; article was that you can treat these
three concepts separately, and by doing so develop a discipline that
makes object-oriented design and implementation feasible in any
language. Furthermore, by doing so, you can develop APIs that are
language independent. To take the &ldquo;array&rdquo; example, what makes it an
&ldquo;array&rdquo; is that you can get and set elements by index, and iterate
over them in index order. That&rsquo;s behavior. If representation,
behavior, and taxonomy are properly separated, you can represent
&ldquo;arrays&rdquo; any way you like, and you can arrange for them to be subtypes
of any type you like, and they&rsquo;ll still be arrays, because they
support &ldquo;array&rdquo; behavior. Representation and taxonomy can be treated
independently as well, but not if your tools insist on conflating
them.</p>
<p>I still think that&rsquo;s true, and useful, but I was always interested in
codifying the ideas of that article more concretely. I was interested
in working with an object system designed around clearly
distinguishing representation, behavior, and taxonomy.</p>
<p>One language that pretty much nails it is Haskell. In Haskell,
representation is the province of datatypes. Behavior is handled by
functions. Taxonomy belongs to typeclasses.</p>
<p>For those unfamiliar with Haskell, the terminology is probably
confusing. Without some experience with Haskell, it&rsquo;s probably not at
all clear how and why &ldquo;datatypes&rdquo; and &ldquo;typeclasses&rdquo; are
different. Briefly, a Haskell datatype is a named description of an
arrangement of data. A typeclass is a named description of a set of
operations. You can make a datatype into a member of a typeclass by
defining functions that implement the operations specified by the
typeclass.</p>
<p>This is pretty close to what I was talking about in &ldquo;Protocols;&rdquo; it&rsquo;s
probably closer than anything else I&rsquo;ve seen to language support for
those concepts. The next closest thing, I think, is the style of
object system exemplified by CLOS (the Common Lisp Object System). In
CLOS, classes describe representation and taxonomy. Generic functions
and methods describe behavior. It&rsquo;s easy and convenient to describe
behavior in CLOS independently of representation or taxonomy. CLOS
does still conflate representation with taxonomy, though it provides
facilities for modifying itself that enable you to work around that
conflation if you really want to.</p>
<p>In February of 2009 I had been using the new Lisp dialect, Clojure,
for about five months on some projects, and was generally pretty happy
with it. One area I wasn&rsquo;t happy with, though, was Clojure&rsquo;s approach
to types and polymorphic functions. Clojure doesn&rsquo;t really have a type
system as such. It has a small number of well-chosen and well-designed
types, and it can transparently use Java&rsquo;s types (Clojure&rsquo;s main
implementation is built on the JVM). For most uses, these two
facilities are more than sufficient, and they work very well. They
fell a little short of what I wanted for some of my work, though. One
of my projects requires ways to specify a large number of structured
data elements with taxonomic relations. The set of elements is open,
and expected to grow over time, so I need a convenient way to add
descriptions of new ones, and ways to ensure that relevant APIs are
defined to work in the proper way over all the values currently
described, and over all those that are yet to be described.</p>
<p>Clojure gives me a lot of what I want to support this scenario, but
not all of it. Clojure&rsquo;s maps provide a great way to describe
structured data, but not a great way to place restrictions on it. I
can say that Foo has fields A, B, and C, but there&rsquo;s no convenient way
to say that A is an automobile and B is a hypotenuse; nor is there a
convenient way to say that a Foo has A,B, and C, and nothing else.</p>
<p>I was even more dissatisfied with the facilities that Clojure provided
for defining taxonomy. Clojure&rsquo;s documentation, and its justifiably
enthusiastic users, make much of the fact that Clojure&rsquo;s derive
function and its polymorphic MultiFns make it possible to define
arbitrary taxonomies. That&rsquo;s true for small values of &ldquo;arbitrary&rdquo;. You
can easily construct any taxonomy, as long as it&rsquo;s a taxonomy that
Clojure was designed to easily construct. Mine wasn&rsquo;t.</p>
<p>The details of the problems don&rsquo;t matter. My main point is that I ran
into a couple of insoluble problems with Clojure&rsquo;s MultiFns, derive,
and hierarchies, and, after some discussion, satisfied myself that the
Clojure community regarded those obstacles as features rather than
bugs. So I did what any sensible Lisp hacker does in a situation like
that: I wrote my own object system.</p>
<p>It began as an existence proof of an alternative way of handling
polymorphic dispatch. There was a little bit of interest in it from a
couple of people, but for the most part the Clojure community reacted
with a shrug. On the whole, they&rsquo;re happy with Clojure&rsquo;s
approach. More power to them.</p>
<p>As I tweaked a few things to respond to casually-mentioned
hypothetical objections, I started to like what I had. I was testing
it by reimplementing important parts of some production code I was
working on. I realized pretty early that the subsystem I was builiding
bore more than a passing resemblance to the ideas in &ldquo;Protocols&rdquo;. I
refactored it a few times. I tried a couple of different
implementation strategies. It got faster, simpler, and more appealing
(to me, that is). Somewhere along the way, I started calling it
Categories.</p>
<p>I have a couple of implementations of it in Clojure now, with somewhat
different APIs. More recently, I ported it to Scheme, so that I can
try it out in a different application context. The API mutated a
little more. I&rsquo;m still refactoring things to try to make the surface
API simpler and easier to understand.</p>
<p>Categories represents the concepts from &ldquo;Protocols&rdquo; pretty
straightforwardly. The basic concepts are:</p>
<p>Types: descriptions of how data are laid out.</p>
<p>Functions: operations that accept zero or more values as parameters,
and that compute and return zero or more values as results.</p>
<p>Domains: descriptions of relations among types.</p>
<p>Functions are polymorphic, and are defined in terms of domains. In
other words, a functions looks at its arguments at runtime and decides
which actual code to run based on what it sees. This is like any other
object-oriented language, as far as it goes. The distinguishing
characteristic of the system is how a function choses a method.</p>
<p>When you construct a function, one parameter to its constructor is a
domain. A domain contains a catalog of types, and a set of rules
(represented as functions) that describe how the types are
related. Domains can tell you things like whether a type is a member
of the domain, whether one type is a subtype of another, and whether a
method can be applied to a particular set of argument values.</p>
<p>Importantly, you can have as many domains as you want, and each one
can work differently. How you represent the relations among types is
entirely up to you. This means that you can pretty easily implement
any kind of dispatching you want. Smaltalk-style, Java-style,
CLOS-style, predicate dispatch—it&rsquo;s all good. The Categories subsystem
defines a default domain that implements a dispatch scheme very
similar to those of CLOS and Dylan (because I like those schemes and
am comfortable with them), but the default is just one domain. If you
want something different, it&rsquo;s easy enough to build it. Just to make
sure, I wrote implementations of Clojure&rsquo;s dispatch and of a
predicate-dispatch scheme. They were easy to do.</p>
<p>When I was first discussing these ideas, someone mentioned some
concern that it wouldn&rsquo;t be possible to implement such a system
efficiently, or to optimize it. In practice, it hasn&rsquo;t been a
problem. There is a tradeoff between exposing the API you need to
implement a domain efficiently, and making the domain API
understandable, and that&rsquo;s been a major issue I&rsquo;m dealing with in
rewrites of Categories. It seems clear at this point, though, that
efficient implementations are doable. The trick is setting things up
so that you can write domains that are efficient without exposing a
confusing array of knobs and switches. I&rsquo;m still working on striking
the right balance.</p>
<p>You can&rsquo;t get a current working version of Categories right now; I
still have its guts out on the table so I can tinker with them. Some
of its early predecessors are readily available if you really want
them, but if you read this and are really interested in Categories,
I&rsquo;d counsel patience. I&rsquo;m folding it into some product code right now,
and making corrections and improvements as that process reveals the
need. It&rsquo;s my intention to nail it down and ship a product that uses
it, then port that version back over to Clojure to support some other
work I&rsquo;m doing in that language. Once I reach that point, if you ask
me for it, I&rsquo;ll give it to you.</p>
<p>Why would you want it? I dunno; you might not. I sure did, though,
enough to build it. Soon I&rsquo;ll see if it was a waste of time, or a
great new tool for my toolbox.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-07-17-heresy/">Heresy</a></h1>
						<span>Jul 17, 2009</span>
					</div>

					<p>I’m coming to the close of a contract, and I’m spending part time
doing what is natural in that situation: looking for new contracts,
and preparing some of my personal projects for release as products.</p>
<p>The first product scheduled for delivery is a Cocoa application for
Mac OS X. Written in Scheme. This, of course, is heresy.</p>
<p>Cocoa applications are supposed to be written in Objective-C. (Well,
to be fair, about a third of the code in this one is Objective-C. The
rest I wrote in Scheme.)</p>
<p>Why would I do a crazy thing like that?</p>
<p>Well, I like Lisp. I’m a Lisp programmer for a reason, that reason
being that Lisp is the clear winner on the Joy-Per-Unit-Effort
scale. I’m not really partisan in my choice of Lisps. I like Scheme
and Common Lisp and Clojure all just fine. If I ever had a favorite
Lisp, it was Dylan, but it’s been a while since Dylan really felt like
a Lisp.</p>
<p>So I was planning to release this product, and I was looking at
options for packaging it. I could certainly have just written it in
Objective-C. I’ve been using Objective-C and Apple’s development tools
(and NeXT’s development tools before that) for nigh onto twenty years
now. It’s a comfortable and familiar ecosystem. But I figured I’d give
Lisp a fair shot before settling on the conventional choice because,
you know, I like Lisp.</p>
<p>Clojure? Nah; the quick route there is a Swing app. The Java Virtual
Machine has many advantages, but delivering great Cocoa apps is not
one of them. Sure, if you spend enough time and effort, you can
achieve a sort of approximation of a Cocoa UI, but it’s not a fun
process. Less Joy Is Bad.</p>
<p>Common Lisp? Maybe. I love Clozure Common Lisp, and it has a great
Cocoa interface. Only trouble is, universal apps are off the table,
for now. Lispworks? Another good possibility. But my license is
getting a little long in the tooth. If I was going to build a product
on it, I should really get a new license, so I can have the latest
version of Lispworks. And y’know? Right now, end of contract, looking
for new contracts, and other revenue streams&hellip;not the best moment to
spend a few thousand bucks speculatively. Prudence. One learns a
modicum of prudence.</p>
<p>I was experimenting with a few options, and
<a href="http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page">Gambit-C</a>
pleasantly surprised me. Gambit’s been installed on my systems since,
oh, probably since 1990 at least. It’s a great Scheme system that has
gotten steadily better over the years. But there’s not really any
Cocoa support there, or so I thought. Go ahead, Google around; you
won’t find much of anything. Except this:</p>
<p><a href="http://jlongster.com/blog/">http://jlongster.com/blog/</a></p>
<p>It describes how this fellow set up remote debugging of a Gambit app
running on the iPhone. Wait a second; Gambit on the iPhone? Um. Turns
out I know something about iPhone apps. Turns out I’ve written some
iPhone products
(<a href="http://www.iphone4kids.net/2009/06/21/firstwords-learning-how-to-spell/)">http://www.iphone4kids.net/2009/06/21/firstwords-learning-how-to-spell/)</a>. If
this guy has Gambit code running on the iPhone, I’m pretty sure I can
get Gambit code to run a Cocoa app, as well.</p>
<p>In fact, it was a piece of cake.</p>
<p>I had allocated a number of hours spread over a week or so to evaluate
several alternative possibilities before just settling down and
building the app in plain, vanilla Objective-C. After the first
session with Gambit, I cancelled all the other evaluations and just
wrote the app in Gambit.</p>
<p>It’s true that there is no Objective-C interface in Gambit. Turns out
you don’t need one. Gambit has a very good foreign-function
interface&ndash;a C interface really. Gambit compiles Scheme to C code, and
then compiles the resulting C code to native code. One advantage of
this approach, which is used by several other Schemes (Chicken and
Bigloo, for example), is that you can embed C code in your Scheme, and
pretty freely mix the two languages. In point of fact, because Gambit
uses the platform’s C compiler, and because Apple’s C compiler handles
Objective-C, you can in fact embed Objective-C code in your Scheme.</p>
<p>For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>application-main
  (<span style="color:#a6e22e">c-lambda</span> () int
&lt;&lt;c-code
   NSApplication *app = [NSApplication sharedApplication]<span style="color:#75715e">;</span>
   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]<span style="color:#75715e">;</span>
   [NSBundle loadNibNamed: [[[NSBundle mainBundle] infoDictionary] objectForKey: @<span style="color:#e6db74">&#34;NSMainNibFile&#34;</span>]
             owner: app]<span style="color:#75715e">;</span>
   [app run]<span style="color:#75715e">;</span>
   [pool release]<span style="color:#75715e">;</span>
   ___result = <span style="color:#ae81ff">0</span><span style="color:#75715e">;</span>
c-code
))
</code></pre></div><p>Well, whaddya know? We don’t need no steenking Cocoa interface.</p>
<p>So currently the app is about two thirds Scheme code and one third
Objective-C code. It works great. It launches in under half a second
and loads its test database in about seventy milliseconds. UI
responsiveness and scrolling are as fast as you could possibly want. I
built the UI the conventional way, in Interface Builder, and it calls
into the Scheme code to display and edit data. The delivered app
bundle is 7MB and it’s a universal application that runs on Tiger and
later.</p>
<p>Turns out Gambit is a great platform for Cocoa app development. Who
knew?</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-05-25-obamus-caesar/">Obamus Caesar</a></h1>
						<span>May 25, 2009</span>
					</div>

					<p>In 27 B.C., Augustus Caesar became the first emperor of Rome, marking
the final end of the Roman Republic. While officially praising and
respecting Rome&rsquo;s republican laws and traditions, he laid the
groundwork for five centuries of autocracy that have become synonymous
with despotism and corruption.</p>
<p>It has been common since the founding of the American republic to
compare and contrast it with that of ancient Rome, and the comparison
can be entertaining, and maybe even informative, if we don&rsquo;t try to
make the analogy closer than it really is. The American presidency is
not, of course, an hereditary monarchy. The powers granted to the
office are not absolute. America is not Rome.</p>
<p>Yet the Roman emperor&rsquo;s office did not start out as an absolute or
hereditary monarchy either. In fact, Augustus and his immediate
successors never held any such office as &ldquo;Emperor;&rdquo; Rome had no such
office. They were called &ldquo;Imperator,&rdquo; but that simply meant commander
of Rome&rsquo;s legions, like our own &ldquo;Commander in Chief.&rdquo; The Roman
Imperator didn&rsquo;t even have the domestic authority wielded by the
American President. Augustus became &ldquo;emperor,&rdquo; not through succession
to a throne, but by adept political maneuvering and deal-making&ndash;and
the shedding of just the right blood, of course. He held power and
authority that are nowhere described or granted in Rome&rsquo;s laws or
traditions. Rome was a republic on paper long after its first emperor
had consolidated his power.</p>
<p>At what point was the Republic over, and the Empire established? Did
Romans during the reign of Augustus know that the Republic was dead?
Surely, they must have. They lamented its passing while Julius Caesar
still lived. We can measure the death of the Republic by the
disappearance of those laments. After the civil wars were over, and
Augustus was established in power, he &ldquo;restored&rdquo; the Senate, by which
we mean that he told the Senate and the people publicly that power was
back in their hands, while privately making sure that his hands were
the ones on all the important levers. Gradually the laments over the
death of the Republic were replaced by praise for its continued
vitality, and Romans once again spoke in praise of the Republic and
the rights of free Romans.</p>
<p>It was a sham, of course. We can look back and with a superior smile
acknowledge what everyone knows: that after the ascension of Augustus,
the Romans may have said they were &ldquo;free citizens&rdquo; of a &ldquo;free
Republic,&rdquo; but they were in fact subjects of an autocrat, the first in
a line that would continue for five centuries and stand forever after
as the paradigm of despotism.</p>
<p>Rome did not declare itself an autocracy; its monarchy was
furtive. Its citizens wanted to think that they were free people, that
their government was constitutionally limited by its laws and
traditions, that there were &ldquo;no kings in Rome.&rdquo; We can chuckle, but
what will posterity say of us?</p>
<p>On May 21st, President Barak Obama proposed a new policy of &ldquo;prolonged
detention,&rdquo; a euphemism for indefinite imprisonment without trial or
charge. His proposal is a breathtaking power-grab, a long step beyond
the worst excesses of the Bush Administration. What&rsquo;s more, he
proposed it as the capstone of a speech, delivered in front of the
document itself, praising the lasting value of the &ldquo;rule of law&rdquo; and
the limits placed on government power by the U.S. Constitution. That&rsquo;s
irony that you can feel in your belly.</p>
<p>Perhaps it&rsquo;s as I began to think during the presidency of George
W. Bush: perhaps the American electorate really doesn&rsquo;t care about the
Constitution anymore. That numbness has been coming for
generations. Presidents and congresses have been trampling the
boundaries of the Constitution and tearing holes in it almost since it
was ratified. Each generation extends new outrages past the outer
limits of the last, until we are asked to accept legal interpretations
of its once-plain language that should embarrass any reasonable
person.</p>
<p>Thomas Jefferson fretted over the Louisiana Purchase, suffering
misgivings because he didn&rsquo;t believe the Constitution granted him the
power to do it. 139 years later, the U.S. Supreme Court could rule
with straight faces (in Wickard v. Filburn) that the commerce clause
of the Constitution grants to the federal government the power to
regulate what a man does with grain produced by his own hands on his
own land for his own use. By that point Americans were already living
with a system of government whose relationship to its charter was
tenuous, if not surreal.</p>
<p>At least, though, politicians had to <em>say</em> that they respected the
Constitution. That seems now to have changed. During the presidency of
George W. Bush, he is rumored to have said &ldquo;Stop throwing the
Constitution in my face. It&rsquo;s just a goddamned piece of paper!&rdquo; The
remark itself is not all that interesting. No one who was present at
the meeting was willing to go on record saying that it happened
(though more than one was willing to say so privately), and even if we
could prove that he did say it, people say all sorts of ill-considered
things without dire consequences. What is more interesting is that the
American public didn&rsquo;t much seem to care. That remarkable utterance
stimulated no public outrage whatsoever.</p>
<p>Evidently, the same public whose elected representatives had impeached
a president for cheating on his wife couldn&rsquo;t bring themselves to care
whether his successor meant what he said when he swore to &ldquo;preserve,
protect, and defend&rdquo; the Constitution of the United States. Evidently,
Americans now regard that oath as a bit of theater required by
tradition, and nothing more, just as the Romans felt obliged to keep
voting certain offices to Augustus, though there was certainly no
danger that he would lose power without them.</p>
<p>At the end of that president&rsquo;s term of office, during the election to
replace him, only one candidate made an issue of the Constitution&rsquo;s
limits on federal power. That candidate was dismissed early as a
crank. His critics were perhaps premature; Ron Paul went on to raise
far more money, attract far more media attention, and make far more
salient points than anyone expected him to. Still, the common
consensus remained that he was a fringe candidate, if not a bit of a
nut. And why? Because he was resolutely committed to the limits the
U.S. Constitution places on governmental authority. How quaint!</p>
<p>We have passed a turning point. The common knowledge is not what it
was when I was a child. Once, people took for granted that the
Constitution seriously limited the powers of government
officials. That notion was wishful thinking, even then; Civil War and
its attendant calamities, economic depression, and facile court
rulings had long since turned the Constitution into a paper tiger.
But public servants were at least expected to act out a pantomime of
respect for it.</p>
<p>We&rsquo;re in a new era now. Barack Obama can stand in front of the
Constitution and make a lovely speech praising its virtues and the
&ldquo;rule of law&rdquo; as a prelude to calling for an act of naked
despotism. Oh, the usual commentators are shocked and appalled, but
there will be another news story tomorrow. And anyway, our own Lex
Galbina, the Military Commissions Act of 2006, is still on the books,
along with more than a century of retreat from the clear limits and
provisions of the Constitution.</p>
<p>Augustus is generally regarded as the first Roman emperor, although he
never officially held any such office, and although Rome went on for
some time pretending that it was still a republic.</p>
<p>Is that where we are now? A candidate in America wouldn&rsquo;t get far by
openly scoffing at the Constitution in so many words, but it&rsquo;s already
okay to scoff at those who take the Constitution seriously. It&rsquo;s okay,
once you&rsquo;re elected, to say &ldquo;it&rsquo;s just a goddamn piece of paper,&rdquo; or
to laud it with praises and in the same breath grab for despotic
power.</p>
<p>Hail Obamus Caesar, Consul of the American Republic.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2009-04-26-more-joy/">More joy</a></h1>
						<span>Apr 26, 2009</span>
					</div>

					<p>Programmers inevitably spend a certain amount of our time fighting
with our tools. There&rsquo;s always something wrong with them, always some
case that they handle badly, always some work we have to do, not
because of the job we&rsquo;re doing, but because of limitations of the
stupid tool.</p>
<p>Programming can be a joy, even programming for a living. I&rsquo;m lucky in
that it&rsquo;s been a joy for me more often than it hasn&rsquo;t. But fighting
with the tools is not a source of joy. In fact, it&rsquo;s the
opposite. More fighting with tools means less joy.</p>
<p>Less joy is bad.</p>
<p>That&rsquo;s why I remain a Lisp programmer: the various forms of Lisp have
given me by far the best return on investment I ever experienced in
terms of joy per unit fighting. I can write code in other
languages. I&rsquo;ve written lots of it. I&rsquo;ve been paid a lot of money to
write a lot of lines of C, C++, Python, shell script, Java, ML,
Objective-C&hellip;just lots of languages, on lots of jobs, in lots of
circumstances. I&rsquo;m still writing Lisp code because of that
joy-to-fighting ratio.</p>
<p>More joy is good.</p>
<p>So what&rsquo;s my favorite programming language?</p>
<p>Well&hellip;</p>
<p>I used to say it was 1992-era Dylan. Dylan was a Lisp that Apple
invented. I worked for several years on Apple&rsquo;s Newton project. Newton
was initially written mostly in Dylan, and I got to write a lot of OS
code in Dylan. That was a time of high joy in my programming life.</p>
<p>It didn&rsquo;t last, of course. The story of Newton&rsquo;s abandonment of Dylan
and its other adventures makes entertaining reading, but the short of
it is that eventually I had to stop programming in Dylan.</p>
<p>Less joy is bad.</p>
<p>Halfway through 2008, one of the original designers and implementors
of Dylan pointed out to me this new Lisp dialect named Clojure:</p>
<p><a href="http://clojure.org/">http://clojure.org/</a></p>
<p>The reason she noticed it was that it&rsquo;s a Lisp whose name is a
misspelling of the world &ldquo;closure&rdquo;, and she&rsquo;s a partner in a Lisp
company named &ldquo;Clozure Associates&rdquo;. Fun coincidence!</p>
<p>It turned out that this new Lisp, named Clojure, was pretty good. In
fact, the more little projects I ported to it, the happier I
became. More joy is good.</p>
<p>Three quarters of a year later, Clojure has become my favorite
programming language for personal projects. Whenever I think about
writing something, I immediately think about Clojure, and if
deployment on the JVM is at all reasonable, then Clojure is probably
what I&rsquo;ll use.</p>
<p>I guess Clojure is my favorite programming language now.</p>
<p>All is not entirely well, though. There&rsquo;s a lot of joy, but there&rsquo;s
still just a little bit too much fighting.</p>
<p>Every time I do anything significant in Clojure, I inevitably stumble
over something that makes me wish I was using Dylan instead.</p>
<p>Bother.</p>
<p>I never used to wish I was using Clojure back in the day, instead of
Dylan. Well, of course, Clojure didn&rsquo;t exist then, but I never wished
I was using anything instead of Dylan.</p>
<p>So why don&rsquo;t I just use Dylan? It&rsquo;s still around, right?</p>
<p><a href="http://www.opendylan.org/">http://www.opendylan.org/</a></p>
<p>Well&hellip;something happened to Dylan over the past seventeen years. It&rsquo;s
not bad or anything. It just doesn&rsquo;t excite me that way its ancestral
form did. It doesn&rsquo;t feel like a Lisp anymore. Less joy is bad.</p>
<p>Still, when I use Clojure, I often wish I had Dylan. When I used
Dylan, I never wished I had something else. What&rsquo;s the problem?</p>
<p>Sometimes I&rsquo;m working on an application that has certain requirements
on its data. I&rsquo;d like to just clearly and concisely write down those
requirements. In Dylan (or a zillion other languages) I&rsquo;d write a type
definition (Dylan calls them classes). There&rsquo;s nothing like that in
Clojure.</p>
<p>Now, Clojure is a Lisp. You can write whatever facilities you need, if
they&rsquo;re not there already. So I wrote my own implementation of record
types, so that I could write down my data requirements
succinctly. Problem solved. Still: more fighting, less joy.</p>
<p>Polymorphic functions are really handy. With polymorphic functions you
can easily write abstract protocols and then implement them for
various different data types without needing to rewrite any of the
protocol code. Very useful, especially when you&rsquo;re writing some big
application that you expect to evolve over time, that you expect to
need to encompass new and evolving data types.</p>
<p>Clojure has its own idea about how polymorphic functions should
work. I don&rsquo;t want to get into the details, because it would get long
and eye-glazing and I&rsquo;d probably start to froth at the mouth. Let&rsquo;s
just say that Clojure&rsquo;s creator and some of its other users believe
that Clojure&rsquo;s approach is a better way to approach polymorphism,
whereas I think it&rsquo;s like someone giggling hysterically as they break
all your toys and poke sharp sticks in your eyes.</p>
<p>More fighting; less joy.</p>
<p>So I wrote my own generic functions subsystem. Now I can make APIs
that don&rsquo;t randomly burst into flame when someone writes code that
uses them. Once again, it&rsquo;s nice that Clojure is a Lisp: it gives me
the tools I need to patch things like this. Still, less joy continues
to be bad.</p>
<p>One of the great things about Clojure is that it&rsquo;s designed to be
hosted on the JVM, and to interoperate seamlessly with Java. That&rsquo;s
quite a useful feature, and Clojure&rsquo;s Java interface is really easy
and convenient. So easy and convenient, in fact, that it&rsquo;s probably
easier to use Java libraries from Clojure than it is to use them from
Java.</p>
<p>On the other hand, Clojure sort of has more than one type system, and
each of the type systems is sort of not really comprehensive. I mean,
on the one hand, every Clojure value is in fact a Java value, but, on
the other hand, knowing that two different values are both instances
of PersistentHashMap may not be all that helpful if each has different
:type metatdata, and your application includes some code somewhere
that distinguishes them on that basis.</p>
<p>What exactly is the type of Clojure value? Well, there&rsquo;s its Java
class, which may or may not be a helpful thing to know, depending on
context. Then there&rsquo;s its metadata, if it&rsquo;s a kind of value that can
have metadata, and if it is, there might or might not be a :type in
that metadata, and that type might or might not be something your code
can use for something useful. It sort of feels like Common Lisp&rsquo;s
types before CLOS came along and absorbed all types into its grand
galactic scheme.</p>
<p>And what if you want to make your own types? Well, there isn&rsquo;t really
any Clojure facility for doing that, but it&rsquo;s a Lisp, right? You can
make whatever kind of type system you want. Of course, the more type
systems you have, the more you have to keep track of, and none of them
are really comprehensive over all possible Clojure values. Well,
except Java&rsquo;s. You can always fall back to Java classes. Except that
if you want to define new ones you have to kind of jump through a few
hoops.</p>
<p>You know what I&rsquo;m going to say: more fighting, less joy.</p>
<p>No doubt someone will skim this and assume I&rsquo;m bashing Clojure. I&rsquo;m
not bashing Clojure. It&rsquo;s my favorite programming language right
now. I just noticed that, hey, I keep wishing it was something
else. That&rsquo;s weird. The last time I was doing a lot of work in my
favorite programming language, I didn&rsquo;t ever wish it was something
else. What&rsquo;s up with that?</p>
<p>Maybe it&rsquo;s that Clojure is still very young and is evolving rapidly
(except, hmm&hellip;Dylan was really young back then and evolving very
rapidly, too&hellip;)</p>
<p>Or maybe it&rsquo;s that Clojure approximates the Lisp I really want,
without actually being it. If so, then Dylan was apparently a closer
approximation, but one that grew farther away over time, rather than
closer.</p>
<p>I guess I&rsquo;ll have to do some thinking about what both Dylan and
Clojure are approximations of.</p>


				</div>
				

				<div class="text-center">
					
<ul class="pagination">
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/">1</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/posts/page/2/">2</a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


				</div>

			</div>
			<div class="col-sm-1 col-md-3 col-md-4">
			</div>
		</div>
	</div>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<script src="http://mikelevins.github.io//js/bootstrap.min.js"></script>

</body>
</html>