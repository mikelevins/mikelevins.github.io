<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="generator" content="Hugo 0.79.1" />
	
	<title>engine of joy - by mikel evins</title>

	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
	<link href="http://mikelevins.github.io//css/bootstrap.min.css" rel="stylesheet">
	<link href="http://mikelevins.github.io//css/strange-case.css" rel="stylesheet">
	

	
	
	<!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

	
	<link href="http://mikelevins.github.io/index.xml" rel="alternate" type="application/rss+xml" title="engine of joy" />
</head>
<body class="scheme-joy">

	<div class="container-fluid">
		<div class="row">
			<div class="col-sm-4 col-md-3 col-lg-3 sidebar">

			
	<div class="sidebar-content">

		<a href="http://mikelevins.github.io/"><h1>engine of joy</h1></a>
		<p>by mikel evins</p>

		

		<ul class="sidebar-menus">
			
		</ul>

		<div class="sidebar-recent hidden-xs">
			<p>Recent Posts:</p>
			<ul>
				
				<li><a href="http://mikelevins.github.io/">engine of joy</a></li>
				
				<li><a href="http://mikelevins.github.io/posts/2020-12-18-repl-driven/">On repl-driven programming</a></li>
				
				<li><a href="http://mikelevins.github.io/posts/">Posts</a></li>
				
				<li><a href="http://mikelevins.github.io/tags/programming/">programming</a></li>
				
				<li><a href="http://mikelevins.github.io/tags/">Tags</a></li>
				
			</ul>
		</div>

		
		<div class="sidebar-contact">
			&#187; <a href="mailto:mikel@evins.net">Email Us</a>
		</div>
		

		<p class="copyright">&copy; 2021. All rights reserved. </p>
		<p class="attr">Powered by <a href="http://gohugo.io">Hugo</a> &amp; <a href="https://github.com/ExchangeRate-API/strange-case">Strange Case</a> (inspired by <a href="https://github.com/poole/hyde">Hyde</a>).</p>

	</div>


			</div>
			<div class="col-sm-7 col-sm-offset-4 col-md-6 col-md-offset-3 col-lg-5 col-lg-offset-3 content">

				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-12-18-repl-driven/">On repl-driven programming</a></h1>
						<span>Dec 18, 2020</span>
					</div>

					<p>Once upon a time, someone with the handle &ldquo;entha_saava&rdquo; posted this question on <a href="https://news.ycombinator.com/item?id=23791152">Hacker News</a>:</p>
<blockquote>
<p>Can someone knowledgeable explain how are lisp REPLs different from
Python / Ruby REPLs? What is the differentiating point of REPL
driven development?</p>
</blockquote>
<p>The answer is that there is a <a href="http://mikelevins.github.io/2020/02/03/programming-as-teaching.html">particular kind of programming</a>
in which you build a program by <em>interacting</em> with it as it runs, and
there are certain languages and runtimes that are designed from the
ground up to support that kind of programming.</p>
<p>Python and Ruby are not examples of such languages.</p>
<p>Why not? That&rsquo;s the crux of entha_saava&rsquo;s question, right? What are
these <strong>repl-driven</strong> programming systems, and what makes them
different from Python and Ruby and every other language that offers a
repl?</p>
<p>For that matter, what&rsquo;s a repl?</p>
<p>The word <strong>repl</strong> is an acronym that stands for <strong>read-eval-print
loop</strong>. The term comes from the history of Lisp. From the start, sixty
years ago, the standard way of working with a Lisp has been to start a
language processor, type expressions at its prompt, and wait for it to
evaluate the expressions and print their results, before prompting for
another expression. Read, eval, print. Loop.</p>
<p>Nowadays, repls are all the rage. Every language and its brother
offers a repl. There&rsquo;s a website, <a href="https://repl.it/">repl.it</a>, whose
entire purpose is to provide all the repls.</p>
<p>It doesn&rsquo;t actually provide <em>all</em> the repls, of course. What&rsquo;s
particularly ironic is that it doesn&rsquo;t provide either of the canonical
repl-driven development environments: Common Lisp and Smalltalk.</p>
<p>That brings us back to entha_saava&rsquo;s question: if Common Lisp and
Smalltalk are repl-driven environments, and Python and Ruby are not,
what&rsquo;s the difference? What do Lisp and Smalltalk have that Python and
Ruby don&rsquo;t?</p>
<p>What they have is a language and runtime system that are designed from
the ground up with the assumption that you&rsquo;re going to develop
programs by starting the language engine and talking to it, teaching
it how to be your program <em>interactively</em>, by changing it <em>while it
runs</em>.</p>
<p>I can hear the objections formulating already. I&rsquo;ve seen them
before. Yes, every language with a repl can do some things in the
repl. Obviously that&rsquo;s true; if it weren&rsquo;t, then the repl would be
entirely useless.</p>
<p>Being able to do <em>some</em> things in the repl does not make an engine
into a repl-driven programming environment. What distinguishes
old-fashioned Lisp and Smalltalk environments is that you can do
<em>everything</em> in the repl. They place no gratuitous limitations on what
you can do; if the language and runtime can do it, then the repl can
do it.</p>
<p>For example, you can ask the current version of Clozure Common Lisp to
rebuild itself from scratch by evaluating the following expression at
the repl prompt:</p>
<pre><code>(rebuild-ccl :full t)
</code></pre>
<p>CCL responds by completely rebuilding itself from source.</p>
<p>The point is not that you would want to rebuild CCL this way all the
time. The point is that there are no artificial limitations on what
the repl can do. The full range of the development system&rsquo;s
capabilities is accessible from the repl.</p>
<p>That&rsquo;s one of the first things I notice when using newer, lesser
repls: I&rsquo;m always running into things I can&rsquo;t do from the repl.</p>
<p>It&rsquo;s not just about freedom from restrictions, though. Proper support
for interactive programming means that the language and its runtime
have positive features that support changing your program <em>while it
runs</em>.</p>
<p>Try this in your favorite repl:</p>
<p>Define a function, <code>foo</code>, that calls some other function, <code>bar</code>, that
is not yet defined. Now call <code>foo</code>. What happens?</p>
<p>Obviously, the call to <code>foo</code> breaks, because <code>bar</code> is not defined. But
what happens when it breaks? What happens next?</p>
<p>If your favorite repl is Python&rsquo;s or Ruby&rsquo;s or any of a few dozen
other modern repls, the answer is most likely that it prints an error
message and returns to its prompt. In some cases, perhaps it crashes.</p>
<p>So what&rsquo;s my point, right? What else could it do?</p>
<p>The answer to that question is the &ldquo;differentiating point&rdquo; of
repl-driven programming. In an old-fashioned Lisp or Smalltalk
environment, the break in <code>foo</code> drops you into a <strong>breakloop</strong>.</p>
<p>A <strong>breakloop</strong> is a full-featured repl, complete with all of the
tools of the main repl, but it exists inside the dynamic environment
of the broken function. From the breakloop you can roam up and down
the suspended call stack, examining all variables that are lexically
visible from each stack frame. In fact, you can inspect all live data
in the running program.</p>
<p>What&rsquo;s more, you can <em>edit</em> all live data in the program. If you think
that a break was caused by a wrong value in some particular variable
or field, you can interactively change it and resume the suspended
function. If it now works correctly, then congratulations; you found
the problem!</p>
<p>Moreover, because the entire language and development system are
available, unrestricted, in the repl, you can define the missing
function <code>bar</code>, resume <code>foo</code>, and get a sensible result.</p>
<p>In fact, there&rsquo;s a style of programming, well known in Lisp and
Smalltalk circles, in which you define a toplevel function with calls
to other functions that don&rsquo;t yet exist, and then define those
functions as you go in the resulting breakloops. It&rsquo;s a fast way to
implement a procedure when you already know how it should work.</p>
<p>If you&rsquo;re a user of old-fashioned Lisp or Smalltalk systems then this
all sounds obvious to you, but that reaction is not common. Surprise
is much more common, or even suspicion: what&rsquo;s the catch?</p>
<p>The catch is that the designers of your language system had to think
that facility through in the planning stages. You don&rsquo;t get a decent
implementation of it by bolting it on after the fact. Breakloops need
<em>full</em> access to the <em>entire</em> development system, interactively, with
a computation and its call stack suspended in the breakloop&rsquo;s
environment.</p>
<p>Let&rsquo;s take another example of a facility designed to support
interactive programming. Once again, try this in your favorite repl:</p>
<p>Define a datatype. I mean a class, a struct, a record type&ndash;whatever
user-defined type your favorite language supports. Make some instances
of it. Write some functions (or methods, or procedures, or whatever)
to operate on them.</p>
<p>Now change the definition of the type. What happens?</p>
<p>Does your language runtime notice that the definition of the type has
changed? Does it realize that the existing instances have a new
definition? When something touches one of them, does it automatically
reinitialize it to conform to the new definition, or, if it doesn&rsquo;t
know how to do that, does it start a breakloop and ask you what to do
about it?</p>
<p>If the answer is &ldquo;yes,&rdquo; then you&rsquo;re probably using a Lisp or Smalltalk
system. If the answer is &ldquo;no,&rdquo; then you&rsquo;re missing a crucial element
of repl-driven development.</p>
<p>Remember: the point is to support programming <em>interactively</em>. You
don&rsquo;t want to have to kill your program and rebuild it from scratch
just because you changed a definition. That&rsquo;s silly; adding and
changing definitions is most of what you do! If your development
environment is going to support interactive development, then it had
better know how to keep your program running when you change some
definitions.</p>
<p>Old-fashioned Lisp and Smalltalk system know how to do that. There are
also a few other kinds of systems, mostly older ones, that know how to
do it.</p>
<p>These are not eccentric new ideas out of left field. They&rsquo;ve been
around for half a century. They contribute materially to productivity
in interactive development.</p>
<p>They&rsquo;re what sets <strong>repl-driven development</strong> apart from mere
development with a repl.</p>
<p>Now, not every programmer prefers that kind of development. Some
programmers prefer to think of development as a process of designing,
planning, making blueprints, and assembling parts on a
workbench. There&rsquo;s nothing wrong with that. Indeed, a
multibillion-dollar international industry has been built upon it.</p>
<p>But if you prefer interactive development, if it&rsquo;s more natural to
you, then it can make you enormously more productive, not to mention
happier in your work.</p>
<p>Interactive development with a proper repl-driven environment is the
exception. Most programming is done in other ways.</p>
<p>As a consequence, there are a lot of programmers out there who&rsquo;ve
never even heard of it, who have no idea that it exists. My intuition
is that some fraction of those programmers would prefer well-supported
interactive programming, and would benefit from it, if they just knew
what it was.</p>
<p>Maybe if enough programmers are exposed to that style of programming
then we&rsquo;ll begin to see new tools that embrace it.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-09-19-what-do-you-mean/">What do you mean, you&#39;re an anarchist?</a></h1>
						<span>Sep 19, 2020</span>
					</div>

					<p>Once in a while it comes up in conversation that I consider myself an
anarchist. Most of the time when people learn that, they have one of
three reactions:</p>
<ol>
<li>I&rsquo;m kidding (or exaggerating, or engaging in some kind of hyperbole for effect)</li>
<li>I&rsquo;m serious, and crazy</li>
<li>I&rsquo;m serious, and they want to know what the heck I mean and how I can hold that position</li>
</ol>
<p>Well, I&rsquo;m not kidding, and as far as I know, I&rsquo;m not crazy, so maybe I
should say what I mean and how and why I hold the position I do.</p>
<p>Part of the problem is that &ldquo;anarchist&rdquo; is a loaded word, as are its
cognates &ldquo;anarchy&rdquo; and &ldquo;anarchism&rdquo;. Usually when people mention
&ldquo;anarchy&rdquo; in casual conversation, they mean violent social
disorder. To be clear, I do not advocate violent social disorder.</p>
<p>Other meanings people commonly have in mind are lawlessness, or
refusal to be involved in organizations or to honor social
conventions. I don&rsquo;t advocate any of those things, either.</p>
<p>Finally, people may think of the familiar trope of &ldquo;bomb-throwing
anarchists&rdquo;, and I&rsquo;m not one of those, either.</p>
<p>When I say I am an anarchist, I mean something fairly specific: I mean
that I don&rsquo;t believe in the legitimacy of state authority.</p>
<p>Those are more loaded words that probably don&rsquo;t do a good job of
saying what I mean, so I&rsquo;ll unpack them some more.</p>
<p>By &ldquo;state&rdquo; I mean something approximating the definition given by the
Prussian sociologist Max Weber: a human community that successfully
claims a monopoly on the legitimate use of physical force within a
given territory.</p>
<p>Another way to say it is that a state is a gang that dominates or
excludes all competing gangs in its territory, claims that its rule is
legitimate, and gets away with it.</p>
<p>My objection is that claiming your rule is legitimate in the absence
of anyone capable of challenging you is not enough to actually make
your rule legitimate. It may make you the de facto ruler; it does not
therefore make you the legitimate ruler.</p>
<p>Many people argue, in effect, that somebody has to be in charge,
therefore whoever actually is in charge is the legitimate authority. I
don&rsquo;t buy it. That would mean that there is no such thing as a
justified insurrection or revolution, that any kind of regime change
is necessarily illegitimate.</p>
<p>I think not. We can point to various rebellions that are generally
held to be justified. Some of them are regarded as the roots of
legitimate social orders. The obvious example is the American
Revolution, a rebellion against an overweening state that is generally
seen as the birth of a new (and legitimate) social order, but there
are others, as well.</p>
<p>My point here is that even people who argue in this way usually allow
that at least some rebellions are right and proper. That can&rsquo;t be true
if mere de facto rulership is enough to confer legitimacy.</p>
<p>So there must be something that distinguishes legitimate from
illegitimate social orders. I think that something is voluntary
contract.</p>
<p>If you have entered voluntarily into an agreement, and if it&rsquo;s not an
agreement that reasonable people would find unconscionable or coerced,
then you have an obligation to abide by it. If you fail to abide by
it, then you owe some reasonable compensation for your failure.</p>
<p>But if someone particularly strong and forceful comes along and tells
you that this is now his territory and you are obliged to follow his
rules, that doesn&rsquo;t obligate you to do so. That&rsquo;s not a legitimate
agreement.</p>
<p>Even if that ruler has overwhelming force on his side, it doesn&rsquo;t mean
he&rsquo;s in the right claiming jurisdiction over you. It may be in his
power to command you, but that doesn&rsquo;t therefore make it within his
rights. You may comply to avoid serious consequences, but that doesn&rsquo;t
make you wrong if you don&rsquo;t.</p>
<p>We are bound to a compact to the degree that we have knowingly and
voluntarily entered into it and agreed to be bound by it. We owe
fulfillment of promises knowingly made. We do not owe fulfillment of
aspirations imposed on us without our knowledge or consent.</p>
<p>That doesn&rsquo;t mean it&rsquo;s a good idea to violate all of the norms that
other people seek to hold us to. Some of them are just good
sense. Basically, don&rsquo;t make war on your neighbors
unnecessarily. Doing so is wicked and foolish.</p>
<p>Some conventions that you are asked to obey are not necessarily right
or just, but refusing would carry a high cost without prospect of a
compensating benefit. In other words, you may think the rules imposed
by the state are unjust or foolish, but it&rsquo;s equally foolish to flout
them for no good purpose, especially if you stand little chance of
succeeding.</p>
<p>Why bother to think this way? What does it accomplish?</p>
<p>I run into that objection sometimes. The simplest answer I can make is
that it&rsquo;s the way I do think, and it happens naturally, without any
particular calculation on my part. I could as easily ask someone, &ldquo;Why
don&rsquo;t you think this way?&rdquo;</p>
<p>But I can make another argument.</p>
<p>Sometimes people object that a peaceful anarchy is impossible and will
never happen, so it&rsquo;s pointless to hold the position that I do.</p>
<p>I think there are valid objections to that claim, but I&rsquo;d rather
observe that a person making this kind of argument probably doesn&rsquo;t
really believe it, or its ramifications.</p>
<p>Approximately no one thinks robbery and murder are okay. Approximately
no one thinks they will ever be entirely eliminated once and for
all. Does that mean that we should approve of them? Of course not.</p>
<p>In the same way, believing that the state will always be around does
not mean you must therefore approve of it. I do not approve.</p>
<p>Wishing for a more voluntary basis for legitimate authority is not
entirely a pipe dream. There is historical precedent in legal systems
based on voluntary courts. One example is that of medieval
Iceland. Another is the Lex Mercatoria. Others are the Xeer courts of
old Somalia, or Anglo Saxon hundredcourts, and other relevant examples
exist.</p>
<p>These are systems of law based on voluntary agreement and negotiated
settlements that existed for centuries without strong central
authorities to enforce their provisions. In Weber&rsquo;s terminology, they
are examples of stateless societies. There was no singular entity
claiming a monopoly on legitimate use of force in a defined
territory. Instead, such legal systems often overlapped with
neighboring, competing ones, functioning more like a market for legal
protections than a state.</p>
<p>Once it becomes clear that such systems have actually existed, a
common objection is that they must have been inferior because they
didn&rsquo;t last forever. Well, no system lasts forever, and if it did,
that wouldn&rsquo;t make it good in any way other than longevity. The
despotism of Pharaonic Egypt lasted for millennia, but that doesn&rsquo;t
mean we should prefer it.</p>
<p>Still, as I said, voluntary legal systems have sometimes lasted for
centuries. In one case, such a system lasted into modern times: the
present day international system of commercial law is essentially the
Lex Mercatoria under another name.</p>
<p>Were voluntary legal systems paradise? Of course not. Neither is any
other known legal system.</p>
<p>They were better in some ways than what we are currently accustomed
to, and probably worse in others. But the authority wielded by a
voluntary court in adjudicating voluntary agreements is an authority I
can believe in.</p>
<p>&ldquo;Might makes right&rdquo; isn&rsquo;t.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-07-09-on-sailing/">On sailing</a></h1>
						<span>Jul 9, 2020</span>
					</div>

					<p>Living is sailing.</p>
<p>When you sail, you are borne here and there by vast forces that are
outside your control. You&rsquo;re carried by the sea, propelled by the
wind, and guided by the sun and stars. None of these elements of
nature pay the slightest attention to your wishes.</p>
<p>The wind and sea may at any moment turn against you. They may swamp
you or dash you against an unfamiliar shore. They may bear you far off
course and maroon you some place far from everything you know. If you
sail long enough, you can be sure that eventually the sea will take
you.</p>
<p>Still, you can become a skillful and accomplished sailor if you&rsquo;re
wise and patient. If you don&rsquo;t waste your effort trying to control the
wind and waves, but instead learn them, if you practice riding out
their tantrums and working with them rather than against them, then
you can learn to sail anywhere you want to go.</p>
<p>Often you won&rsquo;t follow exactly the route you planned, because the wind
and the waves will have something to say about it. Maybe you won&rsquo;t
arrive on time. Still, people can and do sail all over the world. Some
have sailed right around it.</p>
<p>You can&rsquo;t tell the sun how hot to be, or the waves how steep, or the
wind how stiff. You can&rsquo;t command shores not to crush your boat.</p>
<p>But you can learn how to read the sea and how to navigate. You can
learn how to care for your vessel, how to keep it shipshape, when to
put in to port, how to prepare for a stiff blow. You can learn to keep
it properly stocked and in good repair so that it gives you the best
possible chance to ride out rough weather.</p>
<p>My life is a small vessel in a vast ocean. It&rsquo;s at the mercy of
immense forces, but I can still work on it every day. I can batten
down the hatches, replenish the stocks, swab the decks. I can study
the charts, watch the weather, and trust the wind and waves to do what
the wind and waves always do. I can keep an eye on the sun and stars
and practice my skill with sail and tiller.</p>
<p>I&rsquo;l get blown off course. I&rsquo;ll take wrong turns. I&rsquo;ll discover things
I can&rsquo;t do, and there will be places I never make it to before the sea
takes me. But there are also many things I can do and many places I
can visit. A tiny person in a tiny boat can sail all over the world
with a little skill and the patience to wait for a favorable wind.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-02-16-on-young-earth-creationism/">On young-earth creationism</a></h1>
						<span>Feb 16, 2020</span>
					</div>

					<p>Once, around ten years ago, someone in an online discussion said that
they were raised as a young-earth creationist, but had become curious
about the scientific account of the natural world and how it
worked. They wanted to know what the problems with young-earth
creationism were, from a scientific perspective.</p>
<p>I offered them the best answer I could manage. Here it is:</p>
<p>The first thing you have to do is set aside God as an
explanation. Sure, if you assume there&rsquo;s an omnipotent, omniscient,
supernatural creator, then you can explain anything by saying, &ldquo;It&rsquo;s
God&rsquo;s will.&rdquo; The problem is, that doesn&rsquo;t really explain anything. It
doesn&rsquo;t tell you anything that you didn&rsquo;t already know.</p>
<p>Take infectious disease, for example. It&rsquo;s been a scourge of the human
race since prehistory. Saying, &ldquo;It&rsquo;s God&rsquo;s will,&rdquo; or &ldquo;the will of the
gods,&rdquo; for thousands of years didn&rsquo;t help people discover the causes
or cures for diseases. What did help was examining the natural world
with a curious mind, and seeking to understand what was found.</p>
<p>Curious people found out that there are tiny organisms, too small to
see, and they&rsquo;re everywhere. Some of them can colonize our bodies, and
some of those cause diseases. There are also chemicals we can use to
counter those invading organisms, and those chemicals help us defend
ourselves against many diseases.</p>
<p>We didn&rsquo;t learn those things from saying &ldquo;disease is God&rsquo;s
will&rdquo;—regardless of whether it is or isn&rsquo;t. We learned them from
looking at the evidence that the natural world gives us and reasoning
about what we found.</p>
<p>So the first thing you do is set God aside. Then you collect evidence
and see where it leads you. You try to find natural explanations for
the evidence that you find.</p>
<p>So far, that approach has been spectacularly successful.</p>
<p>From that perspective, there are some serious problems with
young-earth creationism.</p>
<p>For example, living things are made of lots of carbon, hydrogen,
oxygen, and nitrogen, and smaller amounts of other things. There&rsquo;s
more than one kind of carbon, each identified by an atomic number. You
can find both carbon 12 and carbon 14 in living things.</p>
<p>It turns out that carbon 14 is radioactive, which means that it falls
apart, turning into atoms that aren&rsquo;t carbon 14 anymore. This happens
at a predictable rate: if you keep a lump of carbon 14 around for 5730
years, you&rsquo;ll find out that half of it isn&rsquo;t carbon 14 anymore; it&rsquo;s
turned into carbon 12.</p>
<p>So that should mean that eventually all the carbon 14 should
disappear, right? It should all turn into carbon 12. Except that
radiation from space striking the earth&rsquo;s upper atmosphere keeps
making more of it at a pretty steady rate. It rains down and mixes
into the atmosphere and gets carried all over the world.</p>
<p>One kind of carbon is as good as another to living things, so plants
absorb it, animals get it by eating the plants or each other, and it
ends up in everything living.</p>
<p>This, too, happens at a steady, predictable rate: out of every
trillion carbon atoms in a living creature, one of them is carbon 14.</p>
<p>But remember: carbon 14 is radioactive. It falls apart. After 5730
years, only one atom in <em>two</em> trillion will be carbon 14, unless the
living thing keeps adding more.</p>
<p>Well, when creatures are alive, they <em>do</em> keep adding more, by
consuming it from their environment. But when they die, they stop
adding carbon 14. The carbon 14 doesn&rsquo;t stop falling apart, though; it
keeps on turning into carbon 12. The longer the corpse lies there, the
more of it falls apart at that steady, predictable rate. So if you
measure the carbon 14 in a corpse, you can use simple arithmetic to
figure out how long ago it died.</p>
<p>When you do that with a lot of dead things, you find out that some of
them died more than 6000 years ago. In fact, a whole lot of them died
<em>way</em> more than 6000 years ago.</p>
<p>This isn&rsquo;t the only way to find out how old things are, by the
way. You can measure age by the radioactive decay of elements besides
carbon. You can use other natural processes that happen at steady
rates, like the deposition of silt, or the changes in magnetism
recorded in rocks, or the rate that minerals trap ions the solar wind
and cosmic rays. When you use several different measures of age and
get close to the same result, you can be pretty confident that you
know the age of the thing you&rsquo;re measuring.</p>
<p>We&rsquo;ve collected age measurements for a lot of things at this point. We
have tons of animal and plant remains that are millions—or in some
cases billions—of years old. We have minerals that are millions or
billions of years old. We have astronomical evidence of things in
space that are millions or billions of years old.</p>
<p>So now our naturalistic picture of the world needs to account for the
fact that we&rsquo;ve found all this evidence of very old things. For
example, we need to account for living things that died a lot more
than 6000 years ago.</p>
<p>Now, we could just say that God created the world with all that
evidence already in it. That&rsquo;s cheating, though. Remember: the rules
are that we look for <em>natural</em> explanations. That&rsquo;s science. If we
resort to supernatural explanations then we&rsquo;re doing theology, not
science.</p>
<p>Also, we&rsquo;d have to wonder why the creator planted gobs of evidence
that the world is billions of years old, if he wanted us to believe
that it isn&rsquo;t, but that&rsquo;s not science, either</p>
<p>The simplest natural explanation for dead bodies more than 6000 years
old is that the earth is more than 6000 years old.</p>
<p>If you run through the mountains of evidence that scientists have
accumulated over the past five hundred years, you&rsquo;ll notice a lot more
situations like this, situations where you either say, &ldquo;Well, God just
made the world like that,&rdquo; or else you try to think of a natural
explanation. The natural explanations tend to contradict young-earth
creationism.</p>
<p>The earth is more than 6000 years old because we can find things in it
that have been around longer than that. Living things evolved from
other, earlier living things because we&rsquo;ve seen it happen in our
present environment, and because we&rsquo;ve found many remains of living
things that are different from anything currently living, and because
we&rsquo;ve found sequences of genetic material from which we can infer
ancestral relationships.</p>
<p>Human beings, for example, are apes because we have the skeletal
structure of apes, the blood types of apes, the reproductive biology
of apes, and the genetic makeup of apes. We know humans are apes in
exactly the same way that we know chimpanzees are apes.</p>
<p>We can measure how similar or different two pieces of genetic material
are, and from doing that we know that humans are closely related to
chimpanzees and bonobos. We also know that there used to be other
human-like species that are gone now, because we&rsquo;ve found their tools
and their remains.</p>
<p>We know that there were stars in the sky more than 6000 years ago
because we know how fast light travels and we can measure the
distances to the stars pretty well. Some stars are so far away that
it&rsquo;s taken more than 6000 years for the light to reach us. For
example, the light from the Andromeda galaxy—the nearest galaxy to our
own—takes two and half million years to reach us.</p>
<p>You can still believe in young-earth creationism, if you want to. You
just have to also believe that, for some reason, the creator planted
evidence against it all over the place.</p>
<p>But if you want a natural explanation of what we see around us, then
young-earth creationism just doesn&rsquo;t do the job.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-02-03-programming-as-teaching/">Programming as teaching</a></h1>
						<span>Feb 3, 2020</span>
					</div>

					<p>Most programming uses an approach that we might call <strong>programming as
carpentry</strong>. We start with some idea of an artifact we want to
build. We analyze the idea into a set of needed parts. We set to work
on our workbench to craft the needed parts and assemble them into a
finished product, then we examine and measure the result to determine
how close we came to our goal.</p>
<p>Next we repeat the process to correct details that have fallen short
of what we want, either because we made mistakes in construction, or
because our original plan was wrong in some way.</p>
<p>There&rsquo;s a different way to approach programming. We might call it
<strong>programming as teaching</strong>. In this approach, we begin by starting up
a runtime that already knows how to be a working program; it just
doesn&rsquo;t know how to be our particular application. By talking to the
runtime interactively, we incrementally teach it the features we need
it to have. When it knows how to provide all those features, we&rsquo;re
done. We can save the accumulated changes to an artifact, and that
artifact becomes our product.</p>
<p>It&rsquo;s less like nailing together an artifact on a workbench, and more
like teaching a student a new set of skills.</p>
<p>Programming as carpentry is far better known and more widely used than
programming as teaching. I&rsquo;d venture to say that most programmers
aren&rsquo;t even aware that programming as teaching is an option. That&rsquo;s a
shame, I think, because for some people it&rsquo;s a better option.</p>
<p>I don&rsquo;t claim that the teaching paradigm is absolutely and objectively
better. I claim only that it&rsquo;s better for some people. Take me, for
example: programming as teaching makes me much happier, faster, and
more productive in my work.</p>
<p>I&rsquo;m not the only one. There are many other programmers who prefer the
teaching paradigm. The reason it&rsquo;s an obscure minority paradigm is
that there are even more programmers—vastly more—who are familiar with
programming as carpentry.</p>
<p>The fact that most programmers don&rsquo;t seem to even know that the
teaching paradigm exists suggests to me that if it were more widely
known, then more people would use it. What are the odds that everyone
who prefers the obscure paradigm is already using it, when most people
don&rsquo;t know it exists?</p>
<p>In some sense, it doesn&rsquo;t matter. The great majority of software is
developed in the carpentry paradigm, and the industry prospers. Is it
really important to evangelize a different paradigm? Probably not, at
least for the sake of the industry as a whole.</p>
<p>On the other hand, I think it is important for the sake of us as
programmers. If I hadn&rsquo;t been exposed to programming as teaching, I
probably never would have known how happy and productive I can be in
my work. A world in which I know about the teaching paradigm is a
better world, at least for me. If there are other programmers who
would prefer the teaching paradigm, and who don&rsquo;t know about it, then
there&rsquo;s a better world awaiting them. All they need is to find out
about it.</p>
<p>So if programming as teaching is such a great idea—even if it&rsquo;s only
great for a minority of programmers—why isn&rsquo;t it better known? I think
it&rsquo;s because programming as teaching requires some tools over and
above what programming as carpentry requires. You have to expend extra
work to make those tools available, and you have to know about them
before you can decide to do that.</p>
<p>You can build a solid carpentry workbench without knowing anything
about the teaching paradigm. The reverse isn&rsquo;t true. A good
programming-as-teaching system is going to need all the tools of the
carpentry workbench. It&rsquo;s going to need parsers and data structures
and code-walkers and code generators. It&rsquo;s going to need file I/O and
performance tools and debuggers, and so forth. It&rsquo;s going to need all
that stuff, but it&rsquo;s going to need some other stuff, too.</p>
<p>Programming as teaching means starting the application running before
it&rsquo;s defined, then defining and redefining features while it runs. It
means inspecting the contents of its memory, stopping control
structures in the middle of executing, and inspecting and changing and
redefining their dynamic context. It means updating the definitions of
functions that are pending on the stack and of datatypes that are used
by existing instances, and relying on the application to keep working
reasonably while you&rsquo;re tinkering around in its guts.</p>
<p>All of those features require substantial runtime support, and if you
want it to work well, the runtime needs to be designed from the start
to support it.</p>
<p>Smalltalk systems have thorough support for that kind of
programming. So do Common Lisp and other old-fashioned Lisp
systems. Outside Smalltalk and Common Lisp and, to some extent FORTH
systems, there aren&rsquo;t many development systems with the full suite of
programming-as-teaching features.</p>
<p>Some of these features exist in some form in modern
programming-as-carpentry systems, but they don&rsquo;t amount to a
programming-as-teaching system. To build a working
programming-as-teaching system, you need to design the whole runtime
from the ground up to support it. Let me give you an example of what I
mean.</p>
<p>The ANSI Common Lisp standard defines a generic function named
UPDATE-INSTANCE-FOR-REDEFINED-CLASS. When the runtime detects a value
whose class has been redefined since it was instantiated, it
automatically calls this function to restructure the value so that it
conforms to the new definition. In effect, it retroactively makes the
value an instance of the new definition instead of the old one.</p>
<p>You can specialize UPDATE-INSTANCE-FOR-REDEFINED-CLASS to correctly
reinitialize instances to conform to their new definitions. If you
don&rsquo;t, then the runtime drops you into an interactive session in which
you can provide the new initialization interactively. You can then
resume execution and the affected value behaves as if it was
originally instantiated from the updated definition.</p>
<p>If you&rsquo;re coming from programming-as-carpentry, you might reasonably
wonder why you would ever want a function like that at all, much less
why you would want it to be part of a language standard. But Common
Lisp was designed by experienced Lisp users and implementors. They
were steeped in the practice of programming as teaching (though they
didn&rsquo;t call it that; they just called it &ldquo;programming&rdquo;).</p>
<p>To the designers of Common Lisp, the normal way of developing a
program was to start the Lisp and then teach it, definition by
definition, how to be the program they wanted. They wouldn&rsquo;t expect to
have to restart their Lisp just because they redefined something;
that&rsquo;s silly. Redefining things was nearly all they did! No, their
expectation was that you redefine things and keep going. It&rsquo;s the job
of the runtime to adapt in a reasonable way to the changes that you
tell it about. It&rsquo;s also the job of the runtime to ask you for help
when it doesn&rsquo;t know what to do.</p>
<p>UPDATE-INSTANCE-FOR-REDEFINED-CLASS is one element of a whole standard
protocol defined by ANSI Common Lisp for changing and redefining
things while the program you&rsquo;re developing continues to run. The
standard describes facilities for defining classes and functions,
updating bindings, catching errors by dropping into an interactive
session where you can inspect and change everything about the dynamic
environment, then tell the function where the error occurred to resume
execution with the new definitions, and generally for accomplishing
every aspect of building and deploying a program through an
interactive conversation with the running program itself.</p>
<p>Smalltalk systems have the same kind of design.</p>
<p>This kind of development environment is a whole that is greater than
the sum of its parts. To get it, you have to design the language and
runtime from the start to support it. You can&rsquo;t convert a carpentry
system to a teaching system by patching in one feature at a time.</p>
<p>Very few development toolchains support the full suite of
programming-as-teaching features. Most of the ones that do have been
around for a long time. Newer languages and runtimes are mostly
designed without any knowledge or understanding of the whole-system
programming paradigm that is embodied in old Lisp and Smalltalk
systems. Even some newer Lisps have been designed without that
understanding.</p>
<p>I worry sometimes that programming-as-teaching is fading away, and I
feel sad that my favorite paradigm might someday disappear altogether.</p>
<p>I don&rsquo;t think that if it does it&rsquo;ll be the end of software
development, or anything apocalyptic like that. I do think that I&rsquo;ll
miss it when it&rsquo;s gone, and I think it&rsquo;ll be sad if new generations of
programmers never have the opportunity to experience it.</p>
<p>There&rsquo;s something magical about gradually turning a program into the
application you want by talking to it while it runs. For some fraction
of programmers, it&rsquo;s the best way of working. I&rsquo;d hate to lose it.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-01-30-lev-chrysotile/">Lev Chrysotile, MD</a></h1>
						<span>Jan 30, 2020</span>
					</div>

					<p>Ixion 11 &ldquo;Lev&rdquo; Chrysotile is the ship&rsquo;s physician aboard
<em>Kestrel</em>. He&rsquo;s the narrator of the first several Kestrel stories.</p>
<p><img src="https://i.imgur.com/zRn64aL.png" alt="Lev Chrysotile"></p>
<p>Lev is a <strong>mech</strong>—that is, an autonomous, self-aware robot. (Such
persons are not referred to as &ldquo;robots&rdquo; in the setting; the word is
considered a slur.) He is a Leslie Model 11 specialized for medical
field maintenance on biological and mech persons.</p>
<p>He&rsquo;s about twelve years old at the beginning of the Kestrel stories,
but, like most autonomous mechs, Leslie Model 11 s roll out of the
factory fully mature and prepared to take care of themselves.</p>
<p>That said, they do tend to be a little naive at first.</p>
<p>Lev met Jaemon Rayleigh at the beginning of his career, when they were
both employed by the Criminal Investigations Unit of the Jovian
Diplomatic Guard on Mars. They became close friends and served two
five-year tours together. When Lev mustered out of the Guard he
accepted Jaemon&rsquo;s invitation to visit Rayleigh Company on
Callisto. There he joined the Company and became <em>Kestrel&rsquo;s</em> medical
officer.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-01-29-against-despair/">Against despair</a></h1>
						<span>Jan 29, 2020</span>
					</div>

					<p>Despair is a pernicious kind of vanity, and it&rsquo;s seductive when things
get hard.</p>
<p>Despair tells you a story like this: &ldquo;I have tried everything and it
hasn&rsquo;t worked. I may as well give up.&rdquo;</p>
<p>This story is a lie.</p>
<p>When despair tells you &ldquo;it hasn&rsquo;t worked,&rdquo; it means that we have
falsely assumed that the world owes us a particular outcome for our
labors. It doesn&rsquo;t. The world promises one thing: the world
itself. Included in that world is our freedom of action and some
inherent capabilities. We are free to act, and we are free to choose
how to act. The world doesn&rsquo;t promise us any particular outcome for
our actions.</p>
<p>&ldquo;It hasn&rsquo;t worked&rdquo; means we expected some specific outcome and didn&rsquo;t
get it. We&rsquo;re disappointed because we didn&rsquo;t get the value we expected
from the effort we expended, but that&rsquo;s because we&rsquo;re deriving value
from the wrong thing. The world does not promise us value in exchange
for effort. We can have it if we want, but the world doesn&rsquo;t supply
it. We have to do that ourselves.</p>
<p>We can&rsquo;t reliably get it from outcomes, because outcomes aren&rsquo;t up to
us. Outcomes are like seasons and weather: they&rsquo;re given to us by the
whims of fortune (or, if you prefer, Providence). We don&rsquo;t choose
them.</p>
<p>What we can choose is where we get our value. If we want to get value
for effort, we have to derive it from something that is up to us—for
example, from the effort itself. We must choose to make efforts that
we value.</p>
<p>Just as &ldquo;it hasn&rsquo;t worked&rdquo; is a false story about where value comes
from, &ldquo;I&rsquo;ve tried as hard as I can&rdquo; is a false story about our freedom
of action.</p>
<p>&ldquo;I&rsquo;ve tried as hard as I can&rdquo; sounds right when we&rsquo;re frustrated. It&rsquo;s
a lie, though. Despair tells us that there&rsquo;s nothing more we can do,
but despair doesn&rsquo;t know that. It&rsquo;s just pretending to know.</p>
<p>We may have tried everything we can think of, but that just means
we&rsquo;ve exhausted our knowledge and imagination for the moment. It
doesn&rsquo;t mean we&rsquo;ve exhausted our options. We always have options we
don&rsquo;t yet know about. Tomorrow we&rsquo;ll know things we don&rsquo;t know today.</p>
<p>Our efforts may have failed up to now, but tomorrow the world will be
different. We don&rsquo;t know what will change, but we can be sure that
something will. Nothing is more certain in life than change. Despair
whispers that nothing significant will be different, but it doesn&rsquo;t
know that, either. It&rsquo;s blowing smoke.</p>
<p>Despair is a liar. If you have a fanciful turn of mind you can think
of it as a demon. It comes to us when we&rsquo;re exhausted and frustrated
and offers a false promise of comfort. It says to us, &ldquo;There, there,
it&rsquo;s all right. There&rsquo;s nothing you can do, anyway.&rdquo;</p>
<p>We don&rsquo;t have to listen. We don&rsquo;t have to believe its lies. We can
recognize that we&rsquo;re exhausted and need to rest. We can give up for
the moment without giving up for good.</p>
<p>Despair wants us to promise that we won&rsquo;t try again, but we don&rsquo;t owe
it that. We don&rsquo;t owe it anything. We can rest and wait for our
strength to return. We can wait for change, for new understanding, for
help that we didn&rsquo;t expect.</p>
<p>We&rsquo;re free to choose a different goal, perhaps a better one.</p>
<p>We&rsquo;re free to choose what to value.</p>
<p>We&rsquo;re free.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-01-25-mai-greenhill/">Mai Greenhill</a></h1>
						<span>Jan 25, 2020</span>
					</div>

					<p>Ordinary Spacer Mai Greenhill, a member of the crew in the <em>Kestrel
Chronicles</em> stories.</p>
<p><img src="https://i.imgur.com/uUh0xpC.png" alt="Mai Greenhill"></p>
<p>Captain Esgar Rayleigh recruited Mai from the Greenhill clan of
Canines who live in the Greater Asgard Wildlife Preserve system on
Callisto. Several companies in the Greater Asgard region recruit crew
from Canine clans, but Mai is the first one recruited by Rayleigh
Company.</p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2020-01-24-amor-fati/">Amor Fati</a></h1>
						<span>Jan 24, 2020</span>
					</div>

					<p><em>Amor fati</em> is a Latin phrase that means &ldquo;love of fate.&rdquo; It&rsquo;s a
concept of virtue that we inherit from the ancient Stoics, though we
can probably thank Friedrich Nietzsche for the Latin phrase and for
its presence in modern discussion<!-- raw HTML omitted --><a href="#f1">1</a><!-- raw HTML omitted -->.</p>
<p>The idea isn&rsquo;t original with Nietzsche. It appears in the writings of
Marcus Aurelius<!-- raw HTML omitted --><a href="#f2">2</a><!-- raw HTML omitted -->—though not in so many words—and in
Epictetus<!-- raw HTML omitted --><a href="#f3">3</a><!-- raw HTML omitted --> before him.</p>
<p>It&rsquo;s not obvious at first glance what it&rsquo;s supposed to mean. &ldquo;Love of
fate?&rdquo; Are we supposed to conceive of Fate as some sort of god and
worship it? Are we being asked to bow down to whatever random
occurrence comes along?</p>
<p>Not quite. The ancient Stoics regarded love of fate as a virtue, and I
agree, but I mean something particular by both <strong>love</strong> and <strong>fate</strong>.</p>
<p>By <strong>love</strong>, I mean caring for something, studying it, understanding
it, cultivating it. I mean a deliberate and purposeful act of
learning, nurturing, and improvement.</p>
<p>I do not mean a feeling of affection, or the moment of joy you might
derive from a pleasing experience. I don&rsquo;t mean a feeling at all.</p>
<p>A perfect example of this kind of love is caring for your
children. That labor may from time to time offer you a warm glow of
pleasure, and you might call that feeling &ldquo;love,&rdquo; but that&rsquo;s not what
I mean. I mean the care you take to nurture and cultivate your
children, regardless of how you feel about it in the moment. I mean
the choice that you deliberately make to care for them even when you
feel vexed and frustrated. That kind of love isn&rsquo;t about how you
feel. It&rsquo;s about what you choose to do. That kind of love is what
tells you that you&rsquo;re wrong when you let your feelings of vexation
dictate what you do.</p>
<p>That love is not a feeling; it&rsquo;s a deliberate course of action.</p>
<p>By <strong>fate</strong>, I mean the sum of your life from beginning to end. I mean
the situation into which you were born, the options offered to you by
fortune and circumstance, and the unfolding of all the consequences of
your choices, good and bad, foreseen and unforeseen. I mean, in terms
familiar to the ancient Romans and Greeks, the thread that the Fates
spin for you, the length of it that they measure, and the cut they
make that finally ends it.</p>
<p>I do not mean predestination or fortune.</p>
<p>Your fate in this sense is all that you are, and have been, and will
be. It includes everything you choose to be and do, and everything
that you don&rsquo;t. It&rsquo;s the circumstances that led to your birth, and the
situations you find yourself in. It&rsquo;s the choices you make and their
consequences, both foreseen and unforeseen. It&rsquo;s everything that is up
to you, and equally important, everything that isn&rsquo;t. It&rsquo;s all you
know of your existence, and all you don&rsquo;t, and everything you will
never know.</p>
<p>Love of fate means properly caring for the sum of your existence.</p>
<p>To love your fate means to see and understand that it&rsquo;s all that you
are, and have been, and will ever be. It&rsquo;s realizing that its care and
cultivation are in your hands and no one else&rsquo;s. It&rsquo;s resolving to
accept it as it is, understand it, and care for it just as you would a
loved one—not because it&rsquo;s without flaw, not because it&rsquo;s everything
you ever wanted, but because it&rsquo;s everything you <em>are</em>.</p>
<p>The reward for loving your fate is not something that you wait to
collect at the end. The reward is in the act of cultivation
itself. It&rsquo;s manifest in the care that you take in this moment and pay
forward to every moment that follows. In caring for your fate,
everything you give, you also receive. Once it&rsquo;s given, it&rsquo;s always
with you. You will never be without it again. Choose wisely.</p>
<p>Not loving our fate means that we make war upon it, upon
ourselves. Not learning ourselves, we cannot know how to properly care
for ourselves. We&rsquo;re as likely to harm ourselves as not. Not caring
for ourselves, we fall into suffering and delusion. We grow lost. We
rob ourselves of the cultivation that might have nurtured us. We lose
the opportunity to collaborate with a future self made stronger and
wiser by good care.</p>
<p>It&rsquo;s sometimes hard to love your fate. No one&rsquo;s fate is all puppy dogs
and rainbows. Fortune offers us, not what we wish for, but a little
bit of this and a little bit of that, chosen according to its whims,
not ours. For every great job offer, there&rsquo;s a disaster in the
wings. For every accomplishment, a tragedy. In bad times it can be
hard to see past the suffering of the moment. A moment of good feeling
may be all we want, and we may be willing to do nearly anything to get
it.</p>
<p>That&rsquo;s fine, as far as it goes, but a good feeling is only a good
feeling. Like any feeling it comes and then it goes, and the whole
time you&rsquo;re right were you were to begin with. If you want something
better, you&rsquo;ll have to build it. It doesn&rsquo;t matter how bruised and
battered you are in the moment, if you want something better, you&rsquo;ll
have to cultivate it.</p>
<p>Your fate is endless—or it might as well be. It lasts as long as you
last, and when it ends, you end with it. You&rsquo;re always in it, whether
you pay attention to it or not. You can ignore it and wander from joy
to despair, at the mercy of fortune, or you can learn to love your
fate. You can acquaint yourself with it, come to know it, accept it,
care for it. You can nurture it and offer it to your future self. You
can accept that gift gratefully and pay it forward it again. You can
forge alliances with better future selves that will exist only if you
cultivate them now, and with all the alliances that those better
selves can make in turn.</p>
<p>But you have to care for your fate. You have to accept it for what it
is, and was, and will be. You have to learn it and understand it. You
have to love it, in the way that you love your children.</p>
<p><em>Amor fati.</em></p>
<p><!-- raw HTML omitted -->1<!-- raw HTML omitted --> Friedrich Nietzsche, <a href="https://www.gutenberg.org/files/52190/52190-h/52190-h.htm#WHY_I_AM_SO_CLEVER">Ecce
Homo</a>,
&ldquo;Why I am So Clever,&rdquo; Section 10<a href="#a1">↩</a></p>
<p><!-- raw HTML omitted -->2<!-- raw HTML omitted --> Marcus Aurelius,
<a href="https://en.wikisource.org/wiki/The_Meditations_of_the_Emperor_Marcus_Antoninus/Book_4">Meditations</a>,
IV.23<a href="#a2">↩</a></p>
<p><!-- raw HTML omitted -->3<!-- raw HTML omitted --> Epictetus,
<a href="http://classics.mit.edu/Epictetus/epicench.html">Enchiridion</a>, VIII<a href="#a3">↩</a></p>


				</div>
				
				<div class="post">

					<div class="post-heading">
						<h1><a href="http://mikelevins.github.io/posts/2015-11-28-book-three-incoming/">Book Three Incoming</a></h1>
						<span>Nov 28, 2015</span>
					</div>

					<p>Here&rsquo;s a sneak peek at the cover for the book I&rsquo;m working on now:</p>
<p><img src="http://i.imgur.com/vgIKUXh.jpg" alt="Imgur"></p>
<p>As the subtitle says, it&rsquo;s the third book about the torch ship <em>Kestrel</em> and her crew. This time the story is less about old damaged ships on the edge of the solar system, and more about crime and punishment in the big (orbital) city.</p>
<p>It took me seven years to write my first unpublished book about this far-future world. These three stories have come much more quickly.I&rsquo;m not sure what the difference is. Perhaps it&rsquo;s that I&rsquo;ve approached these stories with a lighter heart. I want to have fun with them, and I want the reader to have fun. It makes them fun to write. There&rsquo;s still the constant struggle over dumb mistakes I make in the plot or awkwardness caused by my personal quirks and habits, but I&rsquo;m doing something or other differently now that makes the story come out quicker and easier.</p>
<p>Maybe it&rsquo;s just that I get along well with the characters.</p>
<p>You can still find books one and two on amazon:</p>
<p><a href="http://www.amazon.com/Kestrel-Chronicles-2-Book/dp/B0161X4O6K/ref=sr_1_3?s=digital-text&amp;ie=UTF8&amp;qid=1448733049&amp;sr=1-3" title="The Kestrel Chronicles">The Kestrel Chronicles</a></p>


				</div>
				

				<div class="text-center">
					
<ul class="pagination">
  <li class="page-item">
    <a href="/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/2/">2</a>
  </li>
  <li class="page-item">
    <a href="/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


				</div>

			</div>
			<div class="col-sm-1 col-md-3 col-md-4">
			</div>
		</div>
	</div>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<script src="http://mikelevins.github.io//js/bootstrap.min.js"></script>

</body>
</html>
